

Welcome to Building Web Applications with Node.js and Express 4. I'm Jonathan Mills from Pluralsight. Now this course is really going to start from the very beginning with Node.js. I'm not going to assume you know much of anything about Node, and I'm going to walk you through how to set up and build web applications using Node.js. If you need a good Node starting point, this is going to be it. What we're going to talk about is how to build web applications with Node. We'll start from the very beginning, I'll show you how to install Node, how to get Node up and running, and how to use Express to build out your web applications. We'll talk about Node, we'll talk about npm, or Node package manager, how to install packages, how to update packages, and all that stuff. We'll talk about Gulp as our task manager, we'll set up Gulp to run our server, and check our server, and check our code, and pull things in, and we'll do all of that stuff with Gulp, I'll show you how to get that up and running. We'll talk about templating engines and how to not have to write HTML, or how to pull HTML together with some messages coming out of our server side code. And we'll talk about Jade, and EJS, and Swig and all of those, so that you know the differences between them and pick the one that makes the best sense for you. We'll talk about routing, and building out our website, and our routes, and middleware, and all of these terms that you may have heard and you're not quite sure how to use them yet, we'll work though all of that stuff. And we're going to talk about databases. We'll talk about MongoDB, but I'll also show you how to interact with some other databases as well, because not everybody wants MongoDB, not everybody wants to use Angular, all of these different things, I'm only going to talk about Node and Express and then you can plug in the other pieces that you want as needed. So what is Node.js? I know you've heard that work a lot and now everyone thinks server-side JavaScript, which is pretty much exactly what it is, but let's talk for just a second about what Node.js really is. So Node.js is an open source, server-side, runtime environment. Node is a runtime environment, it is not a language. Think about it kind of like you think about .NET, you write code in C#, .NET's your runtime environment. And so Node is going to be kind of like that, it's the wrapper around the code that you're going to write. It is truly cross platform, which is very cool. I can take my Node.js code, or my JavaScript code that runs inside Node.js and I can deploy it to Windows, or Linux, or OS X, or whatever operating system I want, because it's going to run inside that runtime environment. It also uses JavaScript as its language, everybody loves JavaScript, they love using JavaScript in the browser, and now they get to use JavaScript on the server side, and they say that a little bit tongue-in-cheek, a lot of people don't like JavaScript, but I'm going to show you how to use it in a way that makes it maybe a little bit easier and not quite so intimidating. So what is Express? We talked about Node, what's Express and how does that fit into this whole thing? Well, Express is a web development framework for Node.js. Express is the web piece that will be built inside Node.js. It's a very lightweight, un-opinionated, and minimalist web framework that we're going to use to build out our website. It's going to handle our routing, and our page rendering, and all of that stuff for us. Ultimately it's an npm package, it's just a package that's going to sit inside Node, and we're going to write code using the Express objects. So we're going to get this started by going out to nodejs.org in order to get and download our Node.js installation. So, nodejs.org, just click the big green button, Install, and that will download whatever version it is that you need for what we're doing. So if you're on a Windows machine it'll download the MSI, if you're on a Mac it'll download the package file, it'll get whatever you need, get it downloaded. And when that's downloaded double-click Install, I'm not going to walk you through the install process because it's going to be different for everybody, but it's a really simple walkthrough, walk through that install process, and then we'll meet back up when you're done and we'll start talking about command line.

Node and the Command Line

So once you have Node installed you can validate that by typing node --version, and you should get a version that pops up, if that doesn't work there's a couple of things you might look at. One might be make sure that Node is in your path if you're on a Windows machine and make sure that your installation ran fine. Once you get that all figured out, now you've got Node installed and working at the command line. Now Node, remember, is just an interrupter, it's just the wrapper around JavaScript, and so you can actually type node and do your JavaScript right here in the command line. So we can do console.log hello there and it'll actually execute that command and run. And you can go so far as to create variables and then use those variables later. This just underscores the fact that Node is just a runtime, it's just this wrapper around JavaScript that executes commands and does things that we want it to do. It would obviously be horribly inefficient to code a website using the Node command line, so that's not how we do it all obviously, I think you know that. So go ahead and create a directory. I'm going to create a directory for our project, and we're going to call it library. So we're going to go mkdir library and create that, and then we'll cd into that. So the way Node really works is by using a file, so we're going to create a JavaScript file and then we're going to execute that using Node. So I'm going to create a file called app.js and we're going to create that and then we'll open that up in an editor. Now once we've got that open we can kind of do that same thing, we can create a variable, type all that stuff in, and then to run that we just do node app.js, and that will execute that code. Now that's simplistic and I'm sure you guys are all thinking, why are we talking about this? Well, the only reason I'm going through this is because I want you guys to make sure that you grasp the idea that all of our application is just one JavaScript file that's getting executed. We're going to do node app.js, and that's going to pull stuff in from other files and we're going to require things and do all that, but ultimately the entire application is just one JavaScript file that we're running by typing node app.js. And we'll get into some other ways we can execute it as well, but once you really understand that concept it's really easy to follow through any Node application because you know here's the starting point and here's how everything works.

Sublime Text

Now that we're starting to edit code we need to talk a little bit about editors, because the reality is when you're dealing with JavaScript and Node.js there's an abundance of editors out there, and it can be a little overwhelming if you're just new and you're just getting started. So we're going to talk a little bit about editors and what they are, and which ones have what features so that you can start to see what that editor landscape looks like and you can pick the one that feels right to you. Because really they all work, and they all do well, and people are out there using all of them, so there's no right or wrong answer when it comes to picking the right editor, it's just a matter of person preference. So I'm going to walk you through a couple, and I'll kind of show you the differences between the editors, and just pick the one that works right for you, and then we can go on through and keep editing some code. The first text editor we're going to talk about is Sublime, or Sublime Text. And Sublime is a fantastic text editor, and really that's what it's built for is text editing. You can use it for markup, you can use it for code, or you can use it to do whatever you would use Notepad for, except Sublime is really cool and it works really well. It's very extensible, there's a lot of package options out there for it, and you can plug packages into it to turn it into just about whatever you want to use it for. One of the potential draw backs for Sublime is this a commercial editor, it's $70 for the full licensed product. They do let you use it for free forever if you choose to do that, it'll just show up unlicensed, and then it'll be fine you can still use it, and it'll ask you to register every once in a while. I would recommend strongly, if you use it and you really like it you go ahead and pay the $70 so that they can continue to support features. Let's take a quick look at Sublime just so you can get an idea of what it looks like and kind of how it works. So this is a quick look at a project in Sublime Text. Notice you can just kind of click around and see how, the flow looks like. It does have some cool options. So if I'm in app.js and I notice I require a models/bookModel I can just hit option p, type bookModel, and there it is, now it's open, and I can go back and forth. I can also go to View, Layout, and do two column if I have a big monitor, and I can edit files side by side. So it has some nice little features to it, it is a text editor more than an IDE, but it is very extensible, there's a lot of options and a lot of plug-ins that you can download and make it more and more like an IDE in order to get you going. So in a quick little nutshell that's Sublime. That's kind of what it looks like, go back to a single view. If you're interested in Sublime you can check it out at sublimetext.com. Remember it is a commercial product, so $70 to buy it although you can use it forever if you choose to, just notice up in the top right corner, it's going to show Unregistered if you have not purchased Sublime.

Webstorm

Another option for editor is WebStorm by JetBrains, and this is more of a true IDE. It really is built to write code, and that's what it's for, and that's why you use it. It's built by JetBrains and so many of you may be familiar with JetBrains products, IntelliJ, or PyCharm, ReSharper if you're a .NET developer. Those same features and that same kind of feel goes into the WebStorm IDEs. So it may feel a little bit more natural to some of you who have more experience with a true IDE for your development, but this is a commercial editor, it's $99, it's fairly expensive, although nowhere near as expensive as like a Visual Studio Ultimate or something like that, but it is a fairly expensive editor on the high side of what you'll see with our editor options. But, if it increases your productivity then it may very well be worth the cost. So let's take a quick a spin around WebStorm you kind of get a feel for what that looks like. Now this is WebStorm, and WebStorm's going to look a little bit more familiar to you if you're used to a Visual Studio, or an IntelliJ, or something like that. And it really is that true IDE, so it has really good IntelliSense, which some of the other ones don't have so it knows I'm using Node. And it knows if I'm using Node if I right-click and I go to Use JavaScript Library I can select Node.js and it'll know some of those Node.js globals that exists. And then I can do here, if I type res, for response, and hit dot it knows what options I have. And so if I'm going to do res.render, it knows what res.render is and it knows how that works. And so the IntelliSense involved is really kind of cool. The big advantage to WebStorm is going to come in its debugging. So I can actually go over to app.js, and I can run, and I can debug. So I'll set a breakpoint on, let's say right here on this app.use, and I'm going to debug app.js. And it's going to stop, and I can watch bookRouter and I can see the values, everything that exists within that object. It's just very cool and there's a lot of examples of why WebStorm becomes a very powerful option if you're doing that enterprise level Node.js work. I used WebStorm in my RESTful APIs course, so you may have seen it there. I would encourage you to play around with it. This is a true IDE that has a lot of power to it, but it does have a price tag associated with it so there's a decision point to be made with that.

Other Editors

Now there's a couple other editors that are out there that we haven't talked about yet. So Atom is one, and Atom's fairly new to the scene and it is a really, really solid browser. It's more of a modern text editor, it's very lightweight, it's very easy to use, it's very approachable, anybody can get it there and get started. WebStorm can tend to be maybe a little overwhelming with all the features that it has. Atom is very approachable, very easy, and it's hackable to its core. You can change anything, any setting you want to change, anything you want to do, it's right there easy to do, and it is free. So Atom has a very low barrier to entry, very easy to get into, and that's another one that you can check out and use. Brackets is the one I'm going to use for this course. It's a versatile IDE, it does a really, really good job in a lot of different areas. It is very extensible, there's a lot of extensions, I'm actually going to walk you through some of the extensions that I use in Brackets to make it a more powerful IDE. And also it is free as well. There's two other ones I want to talk about real quick. Vim, if you're a Java developer or you've been messing around on the Linux side at all, Vim should be very familiar to you. I used to code in Vim as well, and there are a lot of extensions that make Vim a very powerful option for Node.js development. A lot of people do it and it's really, really nice. A new player to this space is Visual Studio Code, which is really, really cool. It's new enough to me right now that I'm not going to delve into it, but if you're coming from a .NET background, or Visual Studio is something that you've used before, Visual Studio Code might be a good option for you to get in and play around with. It is also available on the Mac, it's available everywhere, so that's kind of a cool option for you to get in and get stuff done.

Configuring Brackets

Now the editor I'm going to be using for this course is Brackets. And you can go to brackets.io and click this big blue Download button here to get started with Brackets. And Brackets is an Adobe product, it's open source, and it's built for web development, so there's some really awesome HTML things built in, and live preview, and some other stuff. But there's some extensions we're going to use to make it a really cool, truly JavaScript development environment. So click Download if you want to play with this one, and I'll kind of walk you through how to get some extensions and those things plugged in. If you don't want to use Brackets, don't worry about it, you can use whatever editor you want. I'm not going to do too much with Brackets specific stuff, I might show you a couple of things here and there throughout the course, but you're free to use whatever editor you want to use. If you want to use Brackets click this Download button and we'll get started with it. Now the first thing you might notice is that your Brackets and my Brackets do not look anything alike, there's a lot of stuff that's different. That's because I have a lot of plug-ins and extensions built into my Brackets. And I'm going to walk you through a couple of those and we can see what's going on. So the first things we're going to do is we're going to click this little Lego looking thing, and that's going to pop up the Extension Manager. Now there's a lot of extensions, you can see the ones I have installed, and there's quite a few of them. There's only a couple that I'm going to talk about here. And the first one's going to be this theme. This is the Delkos-Dark-Theme, and I love this theme because when I click here you see things start to highlight, and it's very easy to see, and it's great for presenting and for recording courses. John Papa turned me onto this one in his Gulp course, which is a course I'm actually going to call out to here in just a little bit to learn more about Gulp. But this theme is awesome, and so the way we get this them is you click here, and we're actually going to install from URL, and the URL is github.com/Brackets-Delkos-Dark-Theme, just type that in and click Install, and that's going to download and install this theme. Now once we're all done you can go up to View, Themes, and pick the Delkos Dark Theme. I also have my font size at 22, that's mostly for mobile devices so that you guys who are watching this on mobile devices can see what's going on, and then I'm going to click Done. That's my Delkos-Dark-Theme. There's a couple other ones I have that I want to show off. So one is Beautify, so click back on this Lego thing, and there's one called Beautify, and you can actually just search and click Install on Beautify. Now Beautify is going to make your code look good. So if I do this, Cmd+Shift+L spreads everything back out for me, so I can just type Cmd+Shift+L it's going to set everything the right way, to look the way I want it to look. The other thing that's going to be majorly different is notice I have tabs across the top, you probably do not. You've got a working file window over here on the side. So this is an extension called Brackets File Tabs. You can just search for it up on the top and install this one. Now, in order to see that you've got to go View, Show Tabs down here on the bottom, if I click that now I'm back to my working files. This is what you probably see right now, I go to View, Show Tabs, and now I get tabs across the top. There's a couple others I have installed that you may notice, see I have got some icons over here at the side. You get those with an extension called Brackets Icons. Css Color Preview does exactly what it sounds like it would do. Snippets is the last one that I'm going to show you. So if you install Snippets down here you'll notice there's snippets, and you can just type a couple of things and it'll pop it out. The one I use most often is cl, so I type cl, hit Tab, and it's got my console.log already written there. You can custom create these. You can come down and do a New, type the text, the Trigger Key, and all that, and it writes it all out for you. So we'll close all of that. Now if you've done all of that your Brackets window should look kind of like mine, so you'll feel a little bit more comfortable knowing what I'm doing and what you're doing are the same thing, and it might be a little bit easier to follow along. Now that we have Brackets up and running we're going to create a new project and we're going to get started on this thing that we're going to build as part of this project.

Node Package Manager

So if we go back over to the code that we started writing earlier, just our little hi, hello world thing that we wrote. This is where we're going to start building out the application that we're going to build over the course of this entire project. The first thing we need to do, however, if we're going to build an Express application is to pull in Express. So we're going to come up here to the top and we're going to do var express = require express. Now this require express is going to pull in a package called Express, and Node has a built-in package management system that's going to deal with all these packages for us and download them, and install them, and track versions, and all that stuff. And this package management system is called Express. All right, so what is npm? Npm is the package management system for Node.js, it's going to manage all of the packages, and we're going to use a lot of them over the course of this project. So Express, Gulp, bodyParser, lodash, all of these things that we want to pull into our Node.js application, npm is going to be responsible for dealing with all of that. It has very easy updates, npm install, npm update, those commands are going to update and install all of your stuff, and it deals with versions for you. And so we're going to spend a little bit of time talking about this and how to get that started. Now we're going to start at the command line for just a minute, and we're going to run npm init, and what this is going to do is it's going to set up npm for this project, and for all the stuff we're doing. So we're going to run npm init and it's going to ask us some questions, and it's going to create a package.json file. It's going to ask us to name our project, and we'll call it library, and the version, and a description, and at this point we're just going to take the defaults. And it's going to ask us to create this package.json file with this information in it. And I'm going to click OK, and you'll see immediately over on the side, package.json file, and if we open that up and look at it, this is where all that stuff that we just entered is going to be, the name, version, description, all of that kind of stuff. The primary use of this package.json file, for us, for what we're going to talk about, is going to be keeping track of all the dependencies and the packages that we have installed for our application. So if we pop back over to our command line we're going to use Express, and this is a course about Express so you can probably assume Express is one of the packages we're going to use. So we're going to do an nmp install express, and we'll do --save. And what --save does is input that into the package.json file. And it's going to install this, and you see over in our package.json file now we have a dependencies section and an express section. Now you see caret in front of express, and that may be a little weird and may be a little scary, because we didn't put that there, what does that mean? So let's take a minute to talk about managing our versions in npm.

Versioning Packages

Now the way npm decides what version it's allowed to install and what version it's not allowed to install is with these little characters in front of the version number. So in this case we have a caret 4.13.3, and what that means is that npm will install any version of this package that is the same major version. So as long it's 4. something, it will install it, which means right now we're looking at 4.13, if 4.14 comes out and you do an npm install, or npm update, it's going to go ahead and take 4.14. Now in a lot of cases that's fine, there's usually aren't too many breaking changes from one version to the next, but that is a risk you're going to take, so another option you have is to use a tilde. Notice how there's a tilde 4.13.3. Now what the tilde's going to do is anything that is a minor version, so 4.13.3, well any 3, 4, 5, 6 that comes after that second dot, it's going to go ahead and install. But if 4.13 goes to 4.14 it's not going to take that upgrade, it's only going to take the largest minor upgrade. You also have the option just to put the version number in, 4.13.3, I'm not taking any upgrades, I'm not doing anything but this specific version. A lot of times this is what you're going to put in to your code, because that way you control when you're going to take an upgrade and when you're not, you have a lot more tight control over it. That's more important for some people than for others, but this is also an option. This is really just a small sampling of the options available to you. There's greater thans, and less thans, and some other things involved there, but really the caret, the tilde, and nothing at all are the options that you're most likely going to use when you're doing npm versioning. Now if we come back over to our code, you'll see caret 4.13.3, if I change this to 4.12.3 and I do an npm install, and I do an npm update, it's going to say everything is good. But what we'll do is we'll just delete this express directory, now there's nothing in there. We'll go ahead and do an npm install again, and what you'll see is express showed up, so when we look at express and we go to the package.json file we installed version 4.13.3, if I come back over to my package.json file and we delete this express, delete that, and I change this caret to a tilde, save that, and run an npm install again, now when I look in express in the package.json file, now you'll see 4.12.4 because it's only going to take the largest minor version that's available, and that's just .4. Okay so, we're going to change this back to 4.13.3, and we're going to come back over and do an npm update, and now we have 4.13.3 installed for Express. Now the reason why this is important and the reason I'm spending so much time on this, is over the course of time this course will age a little bit, and sometimes some of the packages we use might change, but really the course content is not necessarily going to be that different. So what you can do, one of the options you have, is even though I'm going to have a caret here, you can go in and specifically state what version of the packages I'm using in the course, do an npm install and you'll go back and get those specific versions. So if a change is made to bodyParser or to lodash at some point, and it's doing something that's a little different or it's a breaking change, just make sure that in your dependencies section you have the specific thing that we're looking for and that'll get us going.

Summary

So we're just getting started getting Node, and Express, and all of those pieces put together to start building out a web application. But we've done a little bit, so let's summarize real quick. We're talking about building web applications with Node and Express, now we're not delving too far into Angular or any of those other pieces, this is just the Node piece to make sure we really understand how all that works. We talked about what Node is and the fact that it's a server-side JavaScript engine that's really a framework, not necessarily a language, and the language inside Node is JavaScript. Talked about editors and what the different editor choices are, we looked at a couple of them, just so you can kind of figure out what you feel comfortable with, and where your price points are, and those types of things. I'm going to be using Brackets, so we talked a little bit about Brackets, and how to get some things installed, and some extensions, and how to make things look kind of the way I have it looking on my Brackets so that you can follow along maybe a little bit easier. Talked about npm, Node package manager, and how to do an npm install to get packages installed in your package.json file, and all that kind of stuff, and how important that is. And we talked about versioning packages and how you can control what version of what package gets installed into your system. Now this is the bare minimum, we haven't even really started writing code yet, and so that's coming up next. The next thing we're going to do is, now that we've got Express in our environment we're going to start using Express to build out a really simple web app before we start building on all these other pieces to it.

Setting Up Express

Introduction

Welcome to Setting up Express. This is the next module in our series about Building Web Applications with Node.js and Express, and I'm Jonathan Mills from Pluralsight. So in this module we're going to continue this process of building out a web application using Node and Express. We're going to get Express configured, we've started writing a little bit of code, but not very much. In this module we'll get Express set up, it'll be working, it'll be running. We're going to do some very simple routing. We're going to go get a Bootstrap template and we'll play around with that a little bit, and we'll also talk about Bower, which is a front-end package manager, as opposed to npm, which is more of our back-end package manager. Alright, so what are we doing here? We're going to build out a library application. We got to build something so we might as well build this. I read a lot of books. And so we're going to build out an application that's going to keep track of authors, and books, and how those two things tie together, and so there's a lot of things we can do with that and it kind of let's us go in a bunch of different ways, so that's what we're going to do. We're even going to, in the end, tie in with some third-party APIs to pull data down off the internet, so it's a nice little tie in we can do towards the end. So let's get started, let's pop back over to our code that we've started writing and we'll start pulling Express into this and get that moving.

Our First App

All right, so here we are back over in the code that we've been in up until now. We have var express = require express and then just some random stuff. So let's get rid of all of this, and we're just going to do our var express = require express. Now remember that came from our npm_modules, and in here you'll see we have express and our package.json, you'll see we have a dependency on express. All right, so now what this gives us is a references to Express. All that means is we've got something that points to Express and kind of lets us know what that does. It doesn't really gives us the ability to do anything. So what we're going to do is create an instance of that, so we're going to do var app = express, and we're going to execute that. And what that gives us is an instance of Express that now we can do some things with. Now to fire that off we're going to do app.listen. Now app.listen takes a couple of parameters, and the first one, we'll go up here we're going to create a port, and that port is going to be the port that Express listens on on your machine. Now obviously in production you're doing port 80 or port 443, but the application itself rarely listens on that port, usually that's a load balancer or something else. So we want to pass a port in, and so we're just going to for right now, pick let's say 5000, and we're going pass that in to app.listen. And then it takes a callback, and what you'll find, because we're doing JavaScript and because we're doing Node, we're going to do callbacks a lot. Basically what a callback is, is it's just a function that app.listen is going to execute when it's done doing what it's doing. So we're just going to pass in a function and it's going to take an error, but hopefully we won't get one of those. And we're just going to say console.log running server on port, and then we'll pass in that port. Now here I typed 5000, that's not going to work, we're actually going to pass in the port. So now I've created a port and I have Express listening on that port and when I run this it should say running server on port port. So if I pull up my console and I run this again, remember we're going to do node app.js, and we're going to run that, see we get this running server on port 5000. And so what that means is that Express is there, it's listening on port 5000, it's ready to go. Now we haven't told it what to do yet and we haven't built any instructions for that yet, and so that's coming next. But for right now, it's very basic, that's an Express app, it's up and running, it's listening on a port, it doesn't know what to do, but it's there.

NPM Start

Now one thing to talk about real quick before we go any farther, is how we're kicking off our server. Now if I hit Ctrl+C, we started this by typing node app.js, which is great because I named our file app.js, but really that file could be called anything, it could be called server.js, or it could be called library.js, it could be anything and so there's got to be a way that the next person who works on this project doesn't have to care what app.js is, or server.js, or any of that stuff, or the person deploying your code, or if you're going to deploy it to the cloud, and we'll talk about that later, like Heroku, you don't want to have to tell it which file to run. You want to use a standard way to execute your application. And the way we're going to do that is with npm. So if we go back over to our code and we go to our package.json file, there is this scripts section. And right now you see there's a test: echo, Error: no test specified, all that stuff, we're going to add another one called start. And now you see we have start and we're putting in the command node app.js. So there's now a script associated with our package.json file, which is associated with npm that says hey, start is node app.js. So I'll save that, we'll flip back over to command line. And now let's do npm start, and we're going to hit Enter, and that's going to run our server. See how right here it says node app.js, it just executes that command, and then it goes ahead and does the running server on port 5000. Now that's a very standard way to kick off our server, so that no matter who gets a hold of this code, all they have to do type npm start and they're up and running, they don't have to worry about which file to start with or how any of that works.

Simple Routing

So let's pop back over here to our code and let's put a route in so that we can see what happens when Express starts dealing with requests made to it. So, let's come down here under var port = 5000, and we're going to add an app.get, and we're just going to do a /, so that's the home route, so in this case localhost 5000 will execute this. And then we're going pass Express a function that's going to tell it what to do. So this will just be a function and we'll close that out. Now, Express is going to pass this function two things, it's going to pass it in a request and a response. Now the request is information that is coming from the browsers, so if it's a post it'll be all the body, if it's all the headers, it's all that kind of stuff for us to use to figure out what's being asked of us. The response is what we're going to deal with. So in this case we'll do a res.send, and then we'll just send something simple like Hello World. So we're going to pull our console window back up, and we're going to Ctrl+C that, and then we'll start this back up again. Now let's pull up our browser and just do localhost:5000, and you see we get our Hello World. So that's Express taking a request from the browser, so basically a localhost at port 5000 at the root, and sending it something back. We wanted to do something a little different, let's flip back over, we can copy this, do an app.get/books, and say Hello Books. And now if we're going to / we get Hello World, we go to /books we get Hello Books. Let's save that, Ctrl+C, start that back up again, refresh that, we get Hello World, now if I go /books, now I get Hello Books. Alright, now we've got some basic sending back and forth, and those types of things, let's actually go start building out a website. And we're going to start by finding a Bootstrap template for us to use to make our site look good.

Bootstrap Templates

Now when I'm getting started with a new project usually I will get a theme from something like BootstrapZero or Start Bootstrap, or I'll just do a web search for free Bootstrap templates. There's a lot of paid ones out there, there's a lot of free ones out there, it depends on your budget, but just to get started we're going to use a free one. And if you go on to bootstrapzero.com, there are a ton of custom Bootstrap templates that match just about anything you're going to need. And we're going to go down and click this big green button More Bootstrap Themes and Templates, and we'll scroll through these. On the second page right now, for mine, there's this one called Storystrap, and you can even just Google Storystrap Bootstrap Template. This one looks like it's going to work well for us. If I click Live Preview we'll get to see how it looks, and this looks like something where we could have maybe an author name up here, and a book cover, and the book title, and then we can put something in here about whether or not we've read it or not, and then you can click through some categories. There's all kinds of things we can do with this, but that basic idea is something that looks like it might work for us. So let's click Download on this and that's going to download it into a folder. So if we open up an Explorer window, you'll see I now have this .zip file, so I'm going to unzip that. And inside this .zip file, you'll find css, JavaScript, and this index.html, and that's what's going to have everything that we need. So let's create a new folder called public, and we're going to drop our css, which is the bootstrap.css and our styles.css, and our JavaScript files into this public. And then let's create a new folder called src, and inside that we're going to create a new folder called views, now this is where we're going to put all the views, like this index.html, this is where we're going to put all that stuff. So if we come down to views, all right so all we've done, I'm going to delete this and that, all right, all we've done is we've created a public folder that now has our JavaScript and our css, and then we have a src that has a view, and that's what we've got, that's all that's in there. Now we want to see that and make that work. The problem is we have all these JavaScript files and these CSS files, which means that we're going to have the browser making requests to css, styles.css, and bootstrapmin.js, and bootstrapmin.css, and we don't have routes set up for all that stuff. And it would be kind of silly, if you look back over into our code, to have to do an app.get/ for all of the different static files that we're going to have, that's just is dumb. So what we're going to do is we're going to set up the public directory as just a static directory so that everything we do and everything we need that's just CSS files, and image files, and all that stuff is just going to sit in this public directory and our Express server is just going to serve that stuff up.

Static Files

So the way we're going to set up this public directory as a static directory is we're going to come up here, right under our port, and we are going to do an app.use. And app.use allows us to set up some middleware, and we haven't talked about middleware yet and that's fine, we're going to talk about middleware here in a couple of modules. But for right now just know that app.use, whatever we put in here is going to be used by Express first before it doesn't anything else. And we're going to set up a static directory, and what that's going to look like is express.static, and we're going to give it a directory, and in this case it's going to be public, just like that. Now what that's going to end up looking like is anytime a request is made to something, so in this case let's go css/styles.css, anytime a request is made for css/styles.css, the first thing that Express is going to do is look in that public directory and see if there's a static file there, and if there is it's going to server that up. If we put a route after that, that looks like, that it won't get to that, it'll just do the static file. After that then it starts to do the routes. So let's take a look and see how this works through the browser, just to make sure it works. So we'll pull up our command line and we'll do an npm start, and that's going to get everything going. Now here we're going to do localhost:5000 and we get our Hello World. Now if I slide this out of the way a little bit I should be able to go css/styles.css and get my css. If you're getting that, everything's working for you so far, and basically what that means, coming back over here, that request comes into Express, it sees that express.static, it looks in the css directory for styles.css, and then everything works. Now we need to do our index.html. So if we look in our src/views directory we have this index.html file. Now in practice we're going to use things called templating engines and we're going to render HTML files and all that stuff, and that's going to come here in a couple of modules. Honestly for right now, HTML is just another type of static file, we're not doing anything with it, we just need to serve that HTML file back up. So in theory I can copy this and I can do another express.static. I'm going to change this public to src/views, and now we have two static directories set up in our application, the first one being public and the second one being views. So what's going to happen now is it's going to look first in this express.static public directory, and then if it doesn't find the file there it's going to look in src/views, and if it doesn't find a file there then it's going to move on and look at our app.get in our routes. So let's save that, we need to restart our server since we changed our app.js, pull our browser up, now let's do index.html, and that works. Obviously we've got our CSS because it all comes up, our HTML is there. Now in theory I could put an entire static HTML website with links and everything in these two directories and they just work. I could put Angular code in my public JavaScript directory, I could build that whole single page app with static content in these two directories and be done, and just this 21 lines of code is all it takes to make that entire thing happen. Now before we get too excited, let's change a couple of things, because there's some things here that I'm not a big fan of. Look at this index.html file. Now you'll see on line 9, we're pulling in bootstrap.css, and we downloaded that bootstrap.css file as part of our template. I don't really like doing that because I want to use the latest Bootstrap and all of the things that come with the latest Bootstrap. I want to replace this with the official Bootstrap that we can get off of Bootstrap's website. And then on the very next line we're pulling a font-awesome CSS out of bootstrapcdn, which isn't necessarily bad, but really I'd like a little more granular control, so we're going to replace this one as well. If we scroll all the way down to the bottom we've got two script tags, one of them is pulling jquery out of googleapis, and one of them is our bootstrap.min.js file, and both of those we're going to replace. So I've got all of these extra scripts and CSS files that are not necessarily the versions I want to use, and the way I want to use it, and so now we need to go and pull all the latest versions of jQuery and Bootstrap and Font-Awesome to make sure we're using the pieces that we want to use. And we're going to use Bower to do that, which is our front-end package management system, kind of like npm is our back-end, Bower's going to be our front-end. So let's just take a minute to learn about Bower and how to use that.

Bower

So let's talk for just a minute about Bower. Bower is a package manager for our web packages. So, anything that has to do with the front-end like Angular, or Bootstrap, or Font-Awesome, or those types of things, we're going to install using Bower. Npm is the back-end package manager and that's going to be for things like Express and those types of things. Bower is the front-end, npm's the back-end. Now we actually install Bower with npm, so we'll do that here in just a minute. It has a flat package hierarchy, which means that it doesn't install dependencies underneath the things that depend on them. So for example, Bootstrap depends on jQuery, well it's going to install Bootstrap and jQuery at the same level instead of having jQuery installed multiple times for all of the things that are going to depend on it. It works very similar to npm. We do an npm install to install npm packages, we do a bower install to install Bower packages, --save in both cases, all of those things are very similar to each other. We even have a bower.json for all of the dependences, just like in on the npm side we have package.json, on the Bower side we have bower.json. Let's take just a minute and look and see how this works. Now once we've cancelled out of our server we're going to do an npm install bower. And we're going to do a -g, and what that -g is going do is install Bower globally so that we can access it from the command line, because remember we're going to do bower install to install all the Bower related packages. And we'll let that install. All right once that's installed, just type bower and see Bower now works for me at the command line. And here's all of the commands you can do and all that stuff, we're not going to worry about 90% of this stuff, we're just going to do a bower install. And now just like npm, when we did npm, we're going to start by doing a bower init. And it's going to ask us some questions, and we don't care about most of these, we're just going to take the defaults for right now. And you'll see over on the side we now have a bower.json file that has just all the answers to all the things we just did in that command line call. Now the first thing we're going to do is install Bootstrap. So let's do a bower install --save bootstrap, and there we go. Now it created a directory called a bower_components, and under bower_components it's got bootstrap and jquery. And the reason why it installed jquery is if you look inside bootstrap and you go to bootstrap's bower.json file, you'll see down here it has a dependency on jquery. And so when Bower goes and downloads Bootstrap it looks at these dependencies and then it will go in and install the dependencies associated with that package. So in this case, Bootstrap requires jQuery so it goes in and installs jQuery as well. Now it put everything in this bower_components directory, which is cool except that, first of all it's a very long name so if I'm including it in my HTML for CSS files typing that out is painful, but at the same time it's not in my public directory. Remember I set up a static directory called public where I'm going to put all my CSS and JavaScript files and all of that stuff. So what I really want to do is have Bower install these files into my public directory. And there's a really easy way to do that. We're going to right-click up here and we're going to create a new file called .bowerrc. And this is where Bower's going to look for its configuration information. And all that this is going to be is just a JSON document, and we're only going to have one thing in here for right now, and it's directory. Now make sure you put the quotes around directory, every other JSON file we're going to deal with is going to have no quotes on the key side, but in this case make sure you put quotes around the whole thing. And we're going to put this in public/lib. And the reason we're putting it in /lib is css and js in our public directory are for our CSS files and our JavaScript files. We're going to segregate out all the packages that come from Bower into the lib directory, just so we know what the difference is between our stuff and Bower's package stuff. So we're going to save that, and we're going to delete our bower_components directory, Delete. We're going to come back over here and we're going to do a bower install --save bootstrap again, it's going to install everything. And now if you look over here we have a lib, and bootstrap, and jquery. Now I can just go in my index.html, scroll back up to the top, instead of css/bootstrap.min I can do lib/ and follow this down, so it's going to be lib/bootstrap/dist/css/bootstrap. Now that's long, and that's a little bit painful, so we're going to find out a different way to deal with that here in this next module. We're going to use Gulp to deal with that stuff for us. But, let's do this same thing, we'll copy this all the way down to the bottom for our bootstrap.js, lib/bootstrap/dist/js/bootstrap.min. If you look over here, lib/bootstrap/dist/js/bootstrap.min.js. All right, so we've got Bootstrap plugged in, jQuery is going to be, come back over here, lib/jquery/dist/jquery.js, so lib/jquery/dist/jquery.min.js. So we're using the min versions, and that's fine, because we don't really need to look at those at all, so we'll just leave it like that. We'll save that. Now the last piece of this we need is Font-Awesome. So see here on line 10 we've got a link to a bootstrapcdn pulling in font-awesome, and that's cool, but I'm going to use Bower to deal with that for me. So we're going to do a bower install font-awesome --save. Now I didn't show you this before, but we'll look at it real quick. If I go to my bower.json, down here at the bottom now I have two dependencies. I have bootstrap and font-awesome, and if you remember what the little squiggly line means is anything that's 3.3 for Bootstrap I'll use, 3.3.6, 3.3.7, that's all cool. If version 3.4 comes out, Bower will not install that version, it's only going to take the biggest minor version that's available. Same thing for Font-Awesome, 4.4.0, 4.4.1, that's all cool, 4.5 I'm not going to install. All right now we have to use that. So if we look it's lib/font-awesome/css/font-awesome.css. So if we come back over here, lib/font-awesome/css/font-awesome.min.css. So let's save that, come back over here, and refresh, now it died because we didn't restart our server. So let's restart our server, and we do that with npm start, all right now let's come back over, and it's working. But we want to make sure it's working for the right reasons, so if we go to our Developer Tools, if you click on Sources for css, we're doing styles.css, and for lib we're doing jquery, font-awesome, and bootstrap, jquery/dist, font-awesome/css, bootstrap/dist. So you can see using the Google tools, where all of these things are coming from. So it looks like we've got everything set up right, our page is still working, so Bootstrap is up, it's running, it's working, we've got our whole template going, everything's good. There are a couple of things about this that have been very painful, and so we want to deal with that. The first one being having to type all this stuff out. This lib/bootstrap, lib/font-awesome, I don't want to have to deal with that stuff so I'm going to use Gulp to do that for me. Having to restart our server every time I change app.js, that's been kind of painful. So we're going to have Gulp do that for us. I'm going to teach you, using Gulp, how to do a lot of these tasks that have been slowing us down a little bit, and having it do it automatically so we don't have to worry about that stuff.

Summary

All right, so we're working our way through Node and Express, and we're building out a web application. And at this point we actually even have a website to show for it. We've got an HTML file that's serving up some CSS and some JavaScript, and things seem to be working pretty decently right now. We've got Express configured, we were listening on port 5000, we've got a couple of routes, we don't do anything with the routes yet, but we've got a couple there, and we've got some static directories that are serving up HTML and CSS. A little bit of simple routing, we're going to go deeper into routing here in a couple of modules, but we've got some very basic routing going on. We used a Bootstrap template, I usually will start off a project finding a Bootstrap template and installing that, it just skips a lot of hard work and a lot of grunt work. So we got that downloaded, we got that installed, and we got it working. And we have Bower going, so Bower we're using for our packages, our CSS files, our JavaScript files, Bootstrap, and those things, and we're going to continue to use Bower to pull different things in over the course of this project, and the same thing with npm, but now all that's up and running and all of that's working. Now we're going to do some automation. We're going to automate some of this stuff using Gulp. So let's take a look at Gulp and get started with that.

Setting Up Gulp

Introduction

Welcome to Setting up Gulp. I'm Jonathan Mills with Pluralsight. Now, we're in the process of building out a web application using Node and Express. And we've gotten far along enough along now that we've started to see some of the pain involved with building out a web application. Things like having to stop and restart our server every time we make a change, pulling in all of our Bower packages, and things like that, they're monotonous tasks that we don't have to deal with as we're trying to build our code. So, in this module we're going to start talking about Gulp and what Gulp is, and how it works, and how to get it set up, and how Gulp will start to eliminate all of the pain around building out our web applications. We're going to enforce some coding standards, so we'll take a look at JSCS and JSHint and enforce some JavaScript coding standards and some coding styles, just to make sure we're doing things right as we go. For me that's a good way of making sure as I'm typing things out, and as I'm building out my demos, it's something that's going to flag me real quick and say hey, you did something wrong. And so I like to have that safety net, a little bit, while I'm building code. We're going to talk about injecting our CSS and our JavaScript. We're going to use wiredep, we're going to use gulp-inject, we're going to use all those pieces to pull out our CSS and JavaScript and drop them into our HTML file. We're going to auto restart our application, we're going to serve up our application, we'll auto restart it and get it going every time we make a change to a JavaScript file. It's going to be awesome, it saves us a lot of headache, a lot of pain.

What Is Gulp?

Now I've used this phrase Gulp a couple of times and let's take a just a second to talk about what Gulp is and what that's going to do for us. So Gulp is a task manager for your web projects. A lot of people will call it a build tool or something like that, and I don't like use the phrase build tool because you're not really building anything, it's more just straight task management. We've talked about all these tasks we want to do, Gulp's what's going to manage those tasks for us. Now, just like Bower, Gulp's installed with npm, it's an npm package, we're going to get installed that way. Gulp is really easy to use, we're going to do all of this stuff in a very short period of time. It's all code, so we're going to write some code that's going to do all this work for us. No configuration files, nothing all heavy like that, just we're going to write some code, we're going to get this stuff knocked out. And its package based, and to me this is the best part. If I want to do inject, or wiredep, or something like that I just pull that package in and I wrap Gulp around that package and it just does its thing. There's not a whole lot of work involved for our side as far as configuration or getting code written. So over the course of this module I'm going to show you how to set this stuff up. Now I'm not going to go super deep in-depth in Gulp, I'm not going to talk a lot about how it works, and why it works, and all that stuff. If you're interested in that there are other courses here at Pluralsight, especially John Papa's Gulp course, really, really fantastic, and once you're done with this if you're still interested in Gulp and wanting to do more, that's a great course for you to go and watch.

Coding Standards with JSHint and JSCS

Now the first thing we're going to do with Gulp is we're going to do some code quality assessment, and we're going to use something called JSHint. And JSHint is responsible for code quality enforcement for your JavaScript files. It detects potential errors and enforces some coding conventions like making sure you use semicolons, and making sure that your code is set up in the right way, or you're declaring variables before you use them, those types of things. It is easily configurable, so you don't have to just take what they say is the way to do it, you can set it up the way your team wants to work and configure it the way you want to configure it. It's also open source, so that means easy, low barrier to entry, you can get in there and get it done quickly. The other tool we're going to use is JSCS, and this is more about coding styles. JSHint is about coding standards, JSCS is about coding styles. So this is more code style enforcement. It enforces your style conventions like the right amount of indentations, and not having multiple lines, and things like that. We'll get into what JSCS looks for and what JSHint looks for, but between the two of them they cover just about everything that you would want to check at around coding styles. Also easily configurable, really super simple, easy to go, and we'll look at that here in just a second, and also open source, so very low barrier to entry. And then to get started with both of these tools you're going to need a couple of files. And if you go out to my GitHub page, github.com/jonathanfmills, I have a CodingStandards repository that has both a .jscsrc file and a .jshintrc file. Those are the configuration files that you're going to need for both JSCS and JSHint. If we look at them really quick, you kind of see the stuff that they'll look for. So JSCS wants to make sure you have curly braces, for example, or no multi-lined strings, or no mixed spaces and tabs, those types of style things to make sure your code is formatted the way that looks good and the way that your team expects it to be. JSHint, on the other hand, is looking for more coding standards, so CamelCase, make sure your variables are structured the right way, make sure your max length of a line is 220 characters, those types of things. And we'll look at what the difference is and how those work in practice. But these two files are required for you in order to get this thing going. So what I typically do is I just download those two files, then I open up my finder window, and I just paste them in there. So now I have my jscsrc and my jshintrc files in there ready to go. Now the cool thing about Brackets is that Brackets has these two files built in. And the way I have that is if you click on the little Lego, we can see down at the bottom I have JSCS for Brackets and JSHint for Brackets installed as extensions for Brackets. Now you may need to do one more thing before this will show up for you, and that's to go to Debug, and Open Preferences File, and see I have this language, javascript, linting.prefer. Now what this is telling Brackets is that JSHint and JSCS are the preferred linting tools that we're going to be using. So you might have to put those in there if they're not there already to get you all set up and ready to go. Now if I go back to app.js, notice two things, one at the bottom this is a JavaScript file, later on this will be important, but you can select JavaScript, make sure you're there, and then this is going to show us some problems. I'll give you an example of two different things. So first of all, if I take this semicolon off, and save it, now JSHint is telling me, hey you're missing a semicolon, that's not good, you want to make sure you've got all your semicolons there, so I'll add that. The types of things that JSCS is seeing is, hey your style's wrong. They want to see this spread out a little bit more with the space. And because I have that beautify I can hit Cmd+Shift+L, spaces everything out, it does it all right, Window+S, and we'll fix the last error here, get rid of that second space, done. So that's awesome, it's built into Brackets, but I want to enforce that on my build. So, let's have Gulp run JSCS and JSHint on our JavaScript files to make sure things are going the way we want them to go.

JSCS in Gulp

Now to get started with Gulp the first thing we need to do is install it. So we're going to do a npm install -g gulp, and what that's going to allow us to do is run it from the command line, because we're going to do everything with Gulp from the command line. So now I should be able to type gulp, and it runs. Now it failed because it says, hey local gulp is not found. So, try running npm install gulp, so I ran it from the command line, the -g so I could run it from the command line, but now I have to do a local install of Gulp as well. Now instead of doing --save we're going to do --save-dev, and what that's going to do is if we come over to our package.json file now I have this devDependencies folder. And what that means is when I deploy this up to production I don't need Gulp anymore, I don't need Gulp, or JSCS, or any of this other stuff that we're doing, that's only for our local environment. When we deploy to production all I need is the dependencies, I don't need the devDependencies, so it saves some space, it saves some time on build, and all of that stuff, so that's what we're going to do. Now that we've got Gulp we are going to run that one more time, just to make sure it's working, and you'll get an error that says hey, no gulpfile found. All right, we're all good, everybody's on the same page, we're ready to go. So we're going to create a new file called gulpfile.js, and this is where we're going to do all of our Gulp stuff, everything that we want to do around Gulp is going to start right in here. So, first things first, we're going to do var gulp = require gulp. Now remember when I said all Gulp was is just code, we're just going to write some code, and tell Gulp what to do, and it's going to do it all for us. Just like we were doing in our program, Gulp is just another JavaScript file. So, in order to have Gulp do something we need to create a task. So the first thing we're going to do is gulp.task. Now the first task we want to do is to check our styles. So we're going to create a task called style, and we're going to pass that a function and this is the function that Gulp is actually going to execute when you run gulp style. So the way Gulp works is it streams through a series of events to get everything done, and so the first thing we want to do is tell it where we're going to get everything from. Now we want to pull in all of our JavaScript files, but not the JavaScript files under node_modules, because that's not our stuff and we don't really care about that. So we're going to build out this list of files as we go, but for right now we're going to create a thing called jsFiles, and it's going to be *.js, and that's going to include app.js and gulpFile.js, those two things, and then everything under src, so all of our files that are under src, and this is where we're going to put the vast majority of our JavaScript files is down under here. We don't want anything under node_modules or any of that right now, just those two directories. So I can do gulp.src and this jsFiles. Now we're going to pipe that to jshint. Now we don't have JSHint yet, so let's go get that. So we're going to do var jshint = require jshint, and actually we want gulp-jshint. All right, now we need to install that so let's do an npm install --save gulp-jshint. Now let's go ahead and install a couple of other things just so we don't have to keep jumping back and forth. We're going to do gulp-jscs and jshint-stylish. Now I did --save, but we're going to go back and we're going to change that to --save-dev, install all those things. Now if I come back over to my package.json file, you'll see those three new things there, ready to go. Okay, now we've got our .pipe into that, we are going to then pass that on to our reporter. So jshint.reporter, jshint-stylish, and it's just the way the reporter's going to look. Now I actually should be able to save that. Now look down here at the bottom, I've got a problem with JSHint missing semicolon on line 13, that's this line right here. I'm actually going to leave that and we're going to run our Gulp task and we'll see if we get that error in our Gulp task. So let's come back here and we'll just do gulp style, we'll run that, and look at that, in gulpfile.js we have a missing semicolon on line 13. So we'll fix that, and that went away, run it again, and it works just fine. Now if you remember JSHint is just the first piece, the second piece is to run JSCS. So we'll do var jscs = require jscs, actually we want gulp.jscs. Now once I'm done piping out to JSHint Reporter, I can just do another pipe and send it to JSCS, and execute that. Now the only thing I 'm going to change in addition to this is I'm going to return this stream. Now like I said before, I'm not going too in-depth on Gulp and how it works, and the mechanics of it all, because you can get that in other places. For right now I just want to get this stuff in here so that we can go on and actually do the web development that we're looking to do in this course. But the return means I'm returning that stream so that I can use this as subtask in some other areas. So we're going to save that, let's make, a couple of issues here. So when I go back, and we run this again, now I have some style issues that we can fix. So in gulpfile, okay one thing to keep in mind, this unsupported rule right here, that is because if we go back to our package.json notice 2.0.0, this just occurred fairly recently that has deprecated a rule. So if I have to go back into jscs and we scroll down this validateJSDoc, we're going to delete that. That is no longer a rule that's allowed, you probably won't see that, if you pull this out of my GitHub I've already updated my GitHub, so you probably won't see that in what you have. So we'll run this again. All right, now we just have a couple of issues in gulpfile.js. So I'll go back to gulpfil.js, fix those issues, save everything, we'll run this again, and that all works. Okay, so now we have Gulp able to run our styles, our style checker, with JSHint and JSCS ready to go. Now that's just the first piece, that's not all that magical, you shouldn't really be impressed yet, but that's going to be the first piece in a series of events that's going to have us doing a whole bunch of stuff in an automated way.

Setting up Wiredep

Now the first thing we're going to have Gulp do that we actually would have to do by ourselves normally is going to be dealing with our CSS and JavaScript files. If we go over to our index.html, you'll see here we have our bootstrap.min.css, our font-awesome.min.css, and then all the way down at the bottom we have our jquery.min and our bootstrap.min JavaScript files. These are things that we had to put in there by ourselves and we had to change, and as we go through this process we're going to be pulling in more and more JavaScript files, more and more CSS files, and I don't want to have to add those manually every time I do something. So what we're going to have is Gulp inject those Bower packages into my HTML automatically. And we're going to do that using a tool called wiredep. Now to get that going we need to do an npm install wiredep --save-dev. And what that's going to do, if you remember, if we come over to our package.json file, wiredep is now in or devDependencies, you can see it right there. Now in order to use that we're going to over to our gulpfile and we're going to create a new task called gulp inject. Now inside this task we're going to use wiredep, instead of pulling it in up above we're just going to pull it in right here. So we'll do var wiredep = require wiredep. Now in this case we just want to pull in the stream so we're just going to do .stream. All right then down below we're going to do our Gulp pipeline here, so we'll do return, because we start with the return, gulp.src. Now in this case our source files are going to be our HTML. So we're going to do ./src/views/*.html, src not two ss, and then --- now that's going to pull in all of HTML files and get us started, then I'm going to pipe that into wiredep. Now wiredep is going to take some options, and we'll fill those options out here in just second. But then once it's done it's going to pipe that back into our views, and so we do that with a gulp.dest and our views directory again. All right now for these options, so the way wiredep works is it looks at our bower.json file, so let's go to our bower.json file, and it looks at our dependencies, and in this case bootstrap and font-awesome. So the first thing we need to tell wiredep is where that bower.json file is that it needs. So we'll come back over here, let's start with var options, and we'll say the bowerJson file is at ./bower.json. Now it actually wants to be able to do something with this bower.json, so we're going to do a require bower.json, and that's actually going to return back that JSON object so we can do something with it. All right, the next things it's going to need to know is where all this stuff is. So it needs a directory, because it's going to look in the bower.json file and say hey, I need bootstrap, now we need to tell it where to look for bootstrap. So our directory is going to be ./public/lib. Most likely in a future iteration of Bower or wiredep at some point, it'll just look at that bowerrc file. So let's save that. Now the last piece of this that we need to do is come back over to our index.html and let's look down here at our JavaScript. I'm actually just going to delete that JavaScript and up at the top, just so we can put this all in one place, I'm going to put a comma in here. I'm going to do bower:js and endbower, and that should now just inject our JavaScript files. Let's try this, let's just try it out, and see what happens. So I should be able to do bower, or gulp inject, and we get inject because we named this gulp.task inject. So I do gulp inject, I run that, and you see it ran and you already see it happened behind me, I have injected these two JavaScript files. Now it's got ../../public in front of it, and we'll deal with that here in just a minute, there's a way we can get rid of that, not a problem. That's just the JavaScript though, let's do our CSS. And we do that by saying bower:css, and then endbower, the same way we did the JavaScript, just with this. Now this is where it's going to put the CSS files, although when we run this, it's not going to work. And here's why, let's talk a little bit about why this doesn't work because if you've been playing with wiredep and playing with Bower, up until recently that would have worked and now it's now working anymore, and so let's talk a little bit about why. So the way wiredep works, is it looks in your bower.json file and it says, hey look at these dependencies, I am dependent on bootstrap version 3.3.5. If I go to my public lib, which is where all that stuff is, I have this bootstrap directory that also has its own bower.json file and that's what it look at. And so it opens this up and it goes down to the main, and notice in main it has dis/js/bootstrap.js and less/bootstrap.less. So it looks at that and says hey, I have a JavaScript file, dis/js/bootstrap.js and I'm going to drop that in my bower:js, where we saw that working. It does not see a CSS file there, and that is a change that happened if we look back at our bower.json file. Notice my Bootstrap is 3.3.5, this change occurred from 3.3.4 to 3.3.5, where they stopped including that CSS, and so we'll talk about how to fix that here in just a second. I want to show you one more thing about our bower.json. Now if I scroll down, it also looks at dependencies. So wiredep say hey, jquery is a dependency of Bootstrap. So if you notice, in my original bower.json I only have Bootstrap and Font-Awesome, but if I go to my index.html notice it included jQuery automatically for me, and that's because it's a requirement of Bootstrap, and notice it put it up above Bootstrap, and that's super awesome, we like that. Okay, so now we've got to figure out how to get our CSS injected into our HTML. And that's a really simple things to do so don't worry, we'll get there. But if you've been playing around with wiredep and all of sudden it stopped working, that's why and here's how you're going to fix it.

Fixing Bootstrap and Wiredep

Now if we come back over to our bootstrap/bower.json file, the reason why wiredep stopped working when it comes to injecting CSS, is it changed to the Bower spec that says now it prefers that you include in main your sources and not your distributed files. So, in this case instead of doing bootstrap.css, they're just doing bootstrap.less, which is totally cool, and I understand that change, and that's fine, but what we now have to do is tell wiredep where that CSS file is. And we do that by using an override. So if we go back to our bower.json file and down at the bottom, after dependencies we're going to put a comma and then we're going to paste in some overrides. Now the overrides basically is going to take what was in, so let's say for bootstrap if I look at their bower.json they have a main with less and dist, now I'm going to override that with my own main in bootstrap that has the dist JavaScript, the dist/css, and still the less Bootstrap. We're not going to do anything with that in this course, but when you get into compiling the less files and that kind of stuff you might want that in there. And then the same thing for Font-Awesome, I'm overriding their main and I'm including css/font-awesome.min.css. Now if I save that now when wiredep looks in my bower.json file it's going to see some overrides and it's going to use these overrides instead of whatever it finds in Bootstrap or Font-Awesome's bower.json file. Now one of the big advantages of this is notice I can say hey, I want to use the bootstrap.min, or I could not use the bootstrap.min, it's going to be up to me to pick which version of that bootstrap.css file I want to use. Okay, so I'm going to save this, we're going to do our gulp inject. All right now if I go to my index.html, scroll up to the top, you see now I have bootstrap.css and font-awesome.min.css. My CSS is injected and working just fine. Now the last piece of this, though, is I still have these ../../publics, and I don't want that because my HTML needs to look just in /lib/bootstrap or /lib/font-awesome, not with this ../public stuff. So the way we're going to get rid of that is we're going to go back over to our gulpfile, and we're going to add one more thing to our options. We're going to add an ignorePath, and we're going to say ../../public needs to go away, and we'll save that, and rerun gulp inject one more time, go to my index.html, scroll back up to the top, now lib/bootstrap/lib/font-awesome. Everything's working, everything's good, feel pretty good about what we're doing. All right, now these two right here, can now go away, because I'm injecting that with Bower CSS now.

Setting up Gulp-inject

Okay, so that's awesome, we've got half of the job done. We've got all of our Bower dependencies, our Bower CSS and our Bower JavaScripts injecting into our HTML, but that's only half of it. If you look down a little bit, see this css/styles.css, that's our CSS, there's no bower install for our stuff. And so we're going to use a tool called gulp-inject that's going to take our CSS and our JavaScript and inject it, and so then all of our dependencies, whether they're Bower dependencies or our local dependencies, are going to be injected in one place. So we're going to have to start by installing gulp-inject. So we're going to do an npm install gulp-inject --save-dev, and remember --save-dev, if we go over to our package.json file it's going to put it in our devDependencies, see there it is right there, gulp-inject 1.5.0, so keep that in mind. Remember I talked about some breaking changes in Bootstrap, keep aware of what the versions are I'm using so that if you hit a breaking change somewhere you can go in and inject, or you can go in and change your version numbers to match what I'm actually doing. All right, so now that I've got that let's go back over to our gulpfile and we'll start working on gulp-inject. We're going to do that by inserting a line right here, var inject = require gulp-inject. So now we've got inject, we've got wiredep, all of that's there. Now if we scroll down here to where we have wiredep, the next thing we're going to do is .pipe to inject. Now inject is going to take a couple of parameters, so it's going to take its source files. So just like Bower pulled its list of files from our bower.json file, we have to tell inject where all of our stuff is at. So we're going to tell it through that injectSrc, and then it's going to take its own options. Now it's going to be different options, so let's call this injectOptions and we'll create both of those. Okay, so first of all, the source is going to be a gulp.src, because it needs that stream of information. Now, we want to take both our CSS files and our JavaScript files, so let's do this, our CSS files are in public/css/*.css. But we also want to use the JavaScript files, so we're going to use an array here, and the JavaScript files are in js/*.js. All right so that is our source files, we've got CSS and JavaScript. Now we'll want to add one more parameter on to this, because we just need the file names, typically a Gulp source is going to read all the files in and then do some stuff with it. We don't want to read the files, we just need the name. So we're going to take a read false and we're going to pass that in to our gulp.src. Now the second piece of this is injectOptions, not vara, var. All right, injectOptions is the same kind of stuff as what we have in our options for wiredep; however, we already have, we don't need the directory, or the Bower, or any of that stuff that's coming from our source, the only thing we really need is our ignorePath. And in this case it's just going to be /public. All right, so we've got inject with our injectSrc and our injectOptions, that should be it. So let's go over to our index.html, and see we have bower:css, bower:js, the next thing we're going to put in here is inject:css, and endinject, and inject:js, and endinject. All right let's save that, we've got everything saved, let's run this again. We'll run gulp inject, that'll run, and see it injected two files into index.html. And we're going to refresh, now you see we've got, now look we've got a bootstrap.min and a styles.css. Now the reason for that is if we look over in css, notice we still have this bootstrap.min from when we imported the template, so let's delete that, and we want to delete this bootstrap.min.js as well. Save all that, let's run that again. Now sometimes Brackets won't auto update and you have to Refresh File Tree, sometimes it just gets stuck, if yours isn't auto refreshing, that's why. Okay, so look, now we've got our styles.css and we can come down and we can delete this link. Now we don't have any JavaScript of our own yet, so let's create a new file called app.js, and we'll save that one, and we'll run that again. If I run this again, I only get one file into index.html, it's going to be this CSS, so it's not seeing my JavaScript. Let's pop back over to my gulpfile and figure out what's going on. Look at this, this is why, because nothing starts with js, oops, js/, that was a mistype on my part, let's try this again. All right, now see I've got two files, two files injected if I go to index.html, Refresh my File Tree, now I've got my js app and my css styles. So now with this one function, this gulp task inject, I'm injecting all of my Bower dependencies and all of my personal dependencies into all of my HTML files, just by clicking a button. Now you might think that's not that big of a deal right now because we only have one JavaScript file, but if you've been doing Angular development or you're going to get into JavaScript development on the front-end, you're going to end up with a lot of files and they'll be in a lot directories and every once in a while you'll create a JavaScript file, and you'll go run your app, and you'll forget to add it to your HTML. This way it'll automatically do that every time something is changed. Now that automatic piece isn't done yet, we're going to do that next by kicking off our stuff with nodemon.

Working with Nodemon

Now in order to get that magic to happen, the stuff automatically updating as things change, and automatically doing our injecting, and all of that, we're going to use something called nodemon that's going to monitor our files for us and whenever anything changes, it's going to automatically restart our server for us. So the first thing we're going to want to do is pull up our terminal and say npm install save-dev gulp-nodemon, and we'll hit Enter on that. Now if we look at our package.json file, now you'll see that gulp-nodemon 2.0.4. Okay, now that we have that let's pop back over to our gulpfile, scroll up to the top, and pull it in right here, var nodemon = require gulp-nodemon. Once that's done, scroll down, here we've got our style task, and I'm going to collapse a couple of these just to get them out of the way, and now we're going to create another task, a gulp.task. We're going to call this serve. So in order to run this we'll type gulp serve. Now I have the option to pass in an array of other tasks that I want run. So I'm going to want to run style and inject both, and then I'll use my function. Now what that means is that when I type gulp serve in the command line it's going to run style and inject tasks before it'll run our serve task. Now it will run both style and inject asynchronously, they'll both run at the same time, and so make sure that nothing requires the other one. If they do, then make them dependent up in that task. All right now for this function we are going to do a couple of things. The first thing we're going to do is create an options. And this options is going to have everything that nodemon needs in order to run. And so we're just going to give it some basic stuff. The first one being the script, and so this is what is it going to run? So when we say gulp serve and we execute nodemon, what's going to run? And we're going to run app.js, because that's what we've called our JavaScript file. The next thing we're going to put in here is a delayTime, and we're just going to put 1. So it's going to wait a second before it runs that restart. We also have the option to pass in some environment variables, now we're not using these yet, but once I've got this in there I'm going to switch some stuff to use it. And what I'm going to use more than anything is the port. And we're going to set our port to 5000. Now another couple of things we might put in here eventually is our database connection strings and things like that, that'll change from environment to environment. We're going to pull those out of our environment in our Q/A in our production servers. Well in dev I want to set all that stuff up for me and I can just have nodemon do that. The last piece is the watch. And what this is what files is nodemon going to look for and when they change restart everything. So what we've got right up here, if you look, is we've got this var jsFiles, and that's our list of all of our JavaScript files. So if any of that stuff changes, if anything in this jsFile changes we want to restart our server. So we're going to do jsFiles, and that's it for our options. Now we're going to return nodemon, so if I pull back down our gulp-inject, notice right here we have return gulp.src, pipe, pipe, pipe. Well, in nodemon, nodemon's going to deal with all that for us, it's going to do the gulp.src, it's going to do all the piping, it's going to do all that for us. So we're just going to return nodemon and we're going to execute options. Now what we are going to add onto this is a .on. So what nodemon will do is as events fire we have the option to send functions in that will be executed as those events fire. And in this case we're going to do restart, and when restart happens, when nodemon restarts for some reason, we are going to execute a function, and all we're going to do, for right now, is to say hey, we're restarting. And we'll save that. Now if we pull this back up and we just do a gulp serve, so all we're doing is a gulp serve, but because, if I slide this window out of the way, we're going to do a style and an inject. So I'm going to run gulp serve, and it failed, and here's why. So if I scroll back up, there's a lot of errors in JSCS, mostly in our gulpfile. So it ran our styles to make sure everything was good, and then when styles failed it just stopped everything, so let's fix that real quick and then we'll move on. So if we come back over here, luckily for me I can just do a Cmd+Shift+L because I have that beautify plug in, and I'll save that, and now I have JSHint issues, but I do not have JSCS issues anymore. So let's run this again, now it's running, and the reason why its running is JSCS doesn't fail. If I want JSCS to fail then, if I come back to my gulpfile and I scroll up to my styles, I can put something right in here that tells JSCS to fail, and I'm not doing that right now. I'm fine with leaving it as not failing so that we can get stuff going. Now the other thing to notice is that I am running on port 5000, because in my app.js that's what we're using. If I scroll back down I'm going to change this to port 3000. I'm going to save, notice when I saved it, it restarted. It restarted because I changed the JavaScript file, gulpfile.js is a JavaScript file that's going to cause a restart. But notice it didn't change to port 3000, so let's cancel everything, and go to our app.js. Now here it says var port = 5000, I'm going to change that to process.env.PORT and what that's going to do, is that's going to pull out of the environment this port object, and if port exists I'm going to use that, if it doesn't exist I'm going to use port 5000. So if I save that, flip back over, notice here it says 3000, app.js says 5000, so what it should use, if we've done everything correctly, is the 3000. So let's run this, we are up and running on port 3000. So if we look back at our browser and we do localhost 3000, now we're running on 3000. All right so that's it for Gulp, for right now, there's a lot more to Gulp, and there's a lot more things we can do with it, but since this is just a Getting Started with Node we're not going to cover everything that Gulp does. There's a couple other Gulp courses out there, John Papa's course is fantastic and he'll cover a lot more stuff than what I've just covered. So if that is interesting to you, as soon as you're done with this course, pop over and watch that one too.

Summary

So we're working our way through Building a Web Application Using Node and Express. And in this module we started talking about Gulp, and how to set Gulp up, and what Gulp is. And Gulp is essentially a task management system for Node. And over the course of that we talked about how to enforce coding standards. We used JSCS and JSHint to make sure that we're writing our code the right way, using the right standards. We injected our CSS and our JavaScript references into our HTML automatically, which saves us a lot of time and is actually very cool. We used wiredep and gulp-inject to do that. And then we also started talking about auto restarting our application and using nodemon to be the runner of our application and automatically restart as things changed. Now, we've got the framework done, we've got the scaffolding built, we've got all of these pieces in place to make our application work. The next piece is to actually start building out this application. So, now that we've got the framework complete, now let's start writing some JavaScript code. And we're going to start off by doing some templating, and building out our HTML in the right way, and then we'll go from there and start building all of our routes, and everything else. So next module, let's get some templating engines going.

Templating Engines

Introduction

Welcome to Building Web Apps with Node.js and Express 4. In this module we're going to start talking about templating engines. Now we're walking down the path of building out a web application using Node.js and Express, and we've gotten all of the frameworks set up, kind of all the extra stuff, now it's time to actually dig in and start building our application. And to start off we're going to talk about templating engines. Now a templating engine is just something that we're going to use to allow Express to build our HTML pages for us. That way it can embed some pieces of information that it's pulled from an API, or a database, or somewhere, and drop that into the HTML. Now there's a couple of different kinds of templating engines that we're going talk about. We're going to start by talking about Jade. So Jade is a templating engine that has to be compiled, and so I'll tell you the syntax, and how to use Jade, and get that going. Then we'll expose you to Handlebars, which is just another type of templating engine that works just a little bit differently than how Jade works. And then we're going to end with EJS, and EJS is the one we're going to use over the course of this application, in this course, but I want to expose you to a couple of different types because depending on what you're doing, Jade or Handlebars might be a better fit for your environment.

Jade

Now we're going to start off by talking about Jade. So Jade is a templating engine that actually runs through a compiler, it runs through the Jade compiler. So that means what we write is going to look a little bit different than just straight HTML. So let's talk about that for just a second. Here's a standard HTML application. You've got your HTML tags, your head tags, all of those types of things, well when you write that same code in Jade we eliminate the tags, we eliminate the closing tags, and we just use keywords. So I've got HTML, and head, and body, and just keywords instead of using tags. And Jade is whitespace and tab based, which means here I've got a title, and that's inside the head because there's a closing head tag, and that's how that works. Well in Jade if I want title to be inside head it has to be indented. So I have my head and then I have indented title, and that tells the Jade compiler, hey this title is part of my head tag. Down below my p tag and my h1 tag are at the same level, which means the p tag is not part of the h1. So it just looks at your whitespace and your tabs in order to figure out what it's doing. So back over here in app.js, let's get our environment set up to use a templating engine. And before we can do any templating engine, not just Jade, but anything, there's a couple things we have to do, and the first thing we have to do is tell Express where we're going to be storing all of our views. So right here we have an app.use static that says, hey source views, just serve that up static. Now we're going to change that to be an app.set. So we're just going to set a variable to views and we're going to say views are in src/views, and we'll clean that up, there you go. Now, just to be safe we'll stick a ./ on there. Now the next piece, now that we know where our views are going to be, the next step is to say what view engine we're going to use. Now we've only talked about one so far, and that's Jade, we'll talk about a couple of others here in a minute. But let's do an app.set view engine, and so we're just setting a variable inside our application that says, hey view engine is going to be jade. All right, now in order to use Jade we need to install Jade. So let's do an npm --save jade. And if we go back over to our package.json file, there it is right there, 1.11.0 is the version that we're using. All right, now we've got our views, we've got our view engine, let's actually create a really quick view. So New File inside our views, and we'll call that index.jade. All right, now if you're following along with me in Brackets, if you click on the little Lego, I have installed a theme called Jade, the official Jade plugin for Brackets. And that gives me syntax highlighting in Jade template files. So if you look down here at the bottom, you'll see Jade here, and if I click on that this is where I can pick the file type, it defaults based on the extension of the files, so you'll get Jade if you install that down there. All right, let's just do something simple. HTML, head, we'll do a title of MyApp, and we'll do a body, h1 of My App, there you go. That is a very, very simple Jade app, now let's serve that up. So we'll save that, go back over to our app.js, go back over to our app.js, and now right here on line 11 we've got app.get with a slash, and we're doing a res.send Hello World. We're going to change this to a render, and instead of Hello World, we're going to render index, and we're going to save that. All right let's do our npm start, all right now we are up and running. And if we pull our browser up, there we go, My App, our subheading, My App up in the title, that is a basic, basic Jade application. Now in most cases you're not going to be able to do just a simple little HTML, head, title, there's more complicated things that have to be done like we need to add classes, and IDs, and all that kind of stuff, and Jade makes that super easy, so let's pop back over to some slides, I'll walk you through.

Jade and JavaScript

All right, now not only is Jade a compiled templating engine, it also operates as JavaScript. So all of the cool JavaScript stuff that we have everywhere else, we can also apply in Jade. So for example, right here we have a class on our body tag called MyClass. Well the keywords over in Jade operate kind of like JavaScript so that I pass in kind of like a function, hey my class = MyClass and I could pass in an array of those things, or IDs, or whatever else we want to do, we just stick those in parenthesis so that that passes through into our HTML. So let's look at that. So in this case we're back to our Jade. We've got our HTML, our body, all of that kind of stuff. Now I can apply on my body a class, I can also, I can do id = MyId, and if I restart my server, and refresh my page, now you'll see body has the class of MyClass and this h1 has an id of MyId. What's cool about that is you can also do functions, and for loops, and things like that. So let's add down here, let's add a list, and we can actually say each val in, and then an array, and then we'll do an li, refresh that, and there you go, and if we expand this you'll see li 1, 2, and 3. So we have access to for loops, we have access to classes, and all those types of things. We can also create variables, so if I come back up here I can do -, and we use - to have access to some of the JavaScript stuff we want to do, var, var list = that 1, 2, 3, and then we can just use list right there. If we save that, restart, and refresh, notice everything just works exactly the same way. Now that's cool, but that is only so useful. What we ultimately want to do is be able to pass that list in from our main code. So if we delete this, let's go back over to app.js, so if I scroll down to right here, res.render, I can pass in a JSON object with a whole bunch of variables. So in this case I'm going to say list, we're going to do an array with a and b, we'll just save that. If I come back over to index, now, see I don't have list anywhere anymore, now I'm just using list right there. We'll save that, restart our server, refresh, and now you see we've got a and b. So at a very high level, that's how Jade works. The only piece left in this that I do want to touch on just real quick is all of our includes, our JavaScript files, our class files, all of our Bower stuff, getting that in here is really, really easy to do. Basically, right here in the head we do that same thing we did before, but this time we use a slightly different comment character. So we do //- instead of the HTML comments. Now we save this, and if we go over to our gulpfile, and we scroll down, I'm going to change our injects to have our gulp.src be *.jade, and that's the only change I'm going to make. I'm going to save that, and we're going to do gulp inject. Now if we go back over to our index.jade, see it just works automatically, all of our stuff is in there. So for inject and wiredep it doesn't care what you're using, it's a comment with bower:css and a comment with a bower:js, and a comment with inject. So no matter what templating engine you use, whatever the comment characters are that's what you'll use. And all you have to do in your gulpfile is when you're setting your source, whenever you're setting your source just change it to *. whatever it is the extension for what you're doing. So in this case it's jade, and that'll just work for you. All right, so that's it for Jade. Let's pop over and look at some of our other templating options.

Handlebars

Now Jade is great, but it's fairly hefty, you're not really writing HTML anymore, you're writing other stuff and it's converting it to HTML, and there's all this extra stuff involved, and that's too much for some people. Some people would prefer something more minimalist, and that gives us Handlebars. Handlebars is a great minimalist templating engine that lets you write HTML and then plug some variables and some other functionality in as needed. You still have JavaScript, you still get to escape out some JavaScript code, so you can do loops and all that other kind of stuff, and it still allows the variables to come in from outside, but really at its core you're still just writing HTML code. And so let me run through Handlebars real quick and I'll show you how this thing works. Now the first things we're going to do in order to use Handlebars is we're going to do an npm install, save express-handlebars. And that'll install and we'll see it right there, 2.0.1 is the version that we're using. Now if we come back over to app.js, there's just a couple of things we need to do here in order to make Handlebars work. So right here at line 8, we're going to create a new line, and instead of jade we're going to do .hbs, and that's what we're going to use as the extension for our Handlebars files. Two other things we need to do here is we need to create a reference to Handlebars and then set app.engine .hbs, and what that's going to say is, hey .hbs file is going to be handled by Handlebars, and then our view engine .hbs. All right, once all that stuff's done now we just need to create our Handlebars files. So we're going to right-click on our views, we're going to create a new file called index.hbs, and we'll just put some simple HTML in here, just a simple h1, Hello from handlebars. Now we haven't changed anything else, we've created a .hbs file, we've switched our templating engine to Handlebars, that's being handled by a .hbs file. Our app.get is just doing a res.render to index, so the only thing we've changed is what templating engine it's using, which is going to change what file in the views directory we're going to use. So if we switch over, and we restart our server, and we pull up a browser, now we get Hello from handlebars, excellent. Handlebars is up and running and working. Now let's talk about how to do some other stuff with Handlebars. So I'm going to come back over to my .hbs file, actually first let's look at app.js. Notice here on line 16 we're passing in a list of a and b, let's also pass in our title, and we'll just say Hello from render is our title so that we know we're coming from somewhere else. All right, go back over to our index.hbs. Now Handlebars, for its variables uses the little handlebar looking things. So if it sees this, if I do title now, restart our server, refresh our page, now you see Hello from render. So this handlebars, the mustache curly braces is the key character for Handlebars, so anywhere it sees this it's going to use variables. Remember over in Jade, if we look back at our Jade stuff, we just use the equal sign, but in Handlebars we just write HTML and anywhere we want to inject something we just add these little handlebar things. So real quick, let's add that ul back in here. Now for the li I'm going to loop over, we look back at app.js, here we're passing in a list of a and b, so I'm going to loop over list and you can imagine, I do some curly braces like this. But Handlebars has some cool little features, so in this case I'm just going to do a pound sign each, or a hashtag depending on where you are and what you want to call it, a #each list, so for each item in list, we're going to do something, and then we're going to close out this each. We're just going to say this, this is the item that it is iterating over, so we'll save that. Restart our server, and we'll go back to using our Gulp stuff here pretty soon, but for right now I just, we're doing npm start, we'll pull this back up, and we'll refresh, and now you see we've got our a and our b. So that's the 10 second overview of Handlebars. Handlebars basically just lets me write HTML code and then I stick some curly braces in there to do JavaScript code, or do variables, and things like that. Now there's one issue you may notice right off the bat if you're writing Angular code. Now if you've been doing Angular at all you'll know that Angular likes those same curly braces, it does the same thing, and I personally I do mostly MEAN stack development, I do Angular development and Node development all at the same time, and so I like to separate those things out a little bit. So Handlebars isn't really like where I like to end up. Handlebars is very popular, it's really cool, it does a lot of really awesome things, so if you're not doing Angular then it's a great option for you. I do Angular and like to do something a little different, so let's flip over and we'll look at the last templating engine we're going to look at for this course and the one that we're going to end up using for the rest of the course.

EJS

Now we're going to use EJS to finish out the rest of our projects. And so to start with EJS let's pop over, kill our server, and do an npm install, --save ejs. All right, if we pop over to our package.json, you see right here ejs 2.3.4 is what we're using. Now if you go to app.js, I'm going to get rid of the var handlebars, the app.engine, all that stuff, and we're just going to change our view engine to ejs. This one's easier, kind of like Jade was, we just set the view engine and be done. Now I'm going to just rename this hbs file to be ejs, and we'll pop that open. Now EJS looks like this, that really is the big difference between Handlebars and EJS. EJS we do the less than, percent, equals in order to pull variables through and across. Now if I want to do code like this loop, I'm just going to do less than %, and in this case we're going to write some JavaScript code. So I'm going to say for, we'll just write a whole for loop in here. Now I'm going to open my block with a curly brace and then close my whole block. Then down here instead of this close each, I'm just going to close my block. Now, line 11, instead of this we're just going to do an =, and we're going to say list sub i, just like that. We'll save that. Now this is EJS, this really is very similar to what we were just talking about so we're not going to spend a lot of time talking about it, but ultimately what it comes down to is your escape character is greater than, equals, and you can put the equals gives you variable names, if I don't have an equals it's going to execute it as if it's JavaScript. So let's fire our server back up, refresh our page, and notice, actually everything's the same. So let's change that just to make sure it's working. And right here in our EJS we'll just say in EJS, we'll save that, restart our server, there you go. So we've got EJS up and running, we've got all that, now let's embed the template that we have in EJS. So, come back over to Brackets, we have this index.html that's got all this code in it, and we already have the inject, and the Bower, and everything all set up here, so actually I'm going to, I'm going to copy this ul, because we're going to use that, copy that, but then I'm going to delete our index.ejs. And I'm going to rename our index.html to index.ejs. So basically, and this is another reason why I like using a minimalist templating engine, I can take a template off of the internet, off of Start Bootstrap or all these other templating sites and just change it to EJS and I'm up and running. Now right here we have our li, our list of categories. I'm going to drop in our list, our for loop, of lists, so just a and b. So what we should have right now is a nav of just a and b. So let's restart that server, refresh this page, now we have a and b right here. Now I didn't put the nav and everything on those, so let's go clean that up, we'll Ctrl+Z a little bit, it's supposed to be an a tag. So we if come back and right here we add an a tag in here, get rid of these uls, save that, and refresh now, there you go. Now our navigation is working, our template's working, everything's working, it's just awesome. Now that that's all done, and we have a templating engine, we've got Gulp running, we've got all this stuff going, now it's time to actually start building out our application. So in this next module, we're done with this module, in this next module let's start building out our routes. And we'll build out author routes, and book routes, and series routes, and all of those routes so that we can start building a full blown application using Node and Express.

Summary

All right, so in this module we kept marching down the path of building out a web application using Node and Express. And we're getting closer, we've got a lot of stuff working right now, so we're getting ready to actually start building out this web application. But in this module we talked about a templating engine, and what a templating engine is and why we use it. Basically it's just a bridge between our Express application and the HTML that we want to display out to the screen, because we're not doing just static pages, we want some dynamic pages, and the templating engine is what helps us bridge our code with the actual HTML. We started off by talking about Jade, and Jade's a heavyweight templating engine. Basically you're going to write something that kind of looks like HTML and you're going to run it through a compiler and Jade's going to compile that into actual HTML. And Jade is extremely useful, I actually like it a lot, and it's good for keeping your templates clean and sharp so that they're easy to work with. We also talked about Handlebars, and Handlebars is more of a minimalist templating engine. And it had a lot of cool functionality, essentially you're writing HTML and you're just injecting a couple of things in there. It has a lot of built-in features, you may have noticed the #each was a lot easier to do than the full blown for loop we had to do over in EJS, but it conflicts a little bit with Angular, and so that's not the one I'm working with right now, although I do know a lot of people who use Handlebars and it's great. EJS was the last thing we talked about, and we talked about it just very briefly to get us going on how to use EJS. But ultimately where we've ended, right now, is we've got a template, and that template that we've downloaded off the internet for our Bootstrap template now is a .ejs file and we are using that to build out our applications. So in this next module we're going to get started. We're going to start building some routes, and we're going to add data to these pages, and we're going to build a list of books, and a list of authors, and all those types of things so we can make this whole thing work.

Routing

Introduction

So we're moving right along in our course to build out a web app with Node.js and Express. And in this module we're going to talk about Routing. Now we're pretty far along in this process of building out this web app, but we haven't really done anything with the application itself yet. We've built the scaffolding, we've talked about templating engines, we've done all those things, now it's time to get down to actually building out our web application. And we're going to start by building some routes for our application, we've got book routes and author routes. We're building a library application that's going to keep track of some books for us, and so we've got book routes and author routes. And we're going to build out /books, /author, all those types of things. And so by the end of this module we'll actually have what looks like a working web application, and then we'll start hooking up databases and all of that stuff after that. So let's get started.

Navigation

Now if you've been following along up until now we've got a web application called library that we've built out quite a bit. We've got our gulpfile sitting here that does our gulp serve, and our gulp inject, and gulp style. In this last module we built out our index.ejs, which is our application main page, that's our index page, and now we're going to start building out our navigation. And so if we scroll down to right here, line 30, we've got our navbar-header and that's where our navbar starts. Now about line 41, right here, we've got this for loop that loops through our navigation to get our list of navigation items. So let's go back over to our app.js and let's build this navigation out a little bit. So, if we scroll down to our app.get we've got our title, Hello from render, and list of a and b. So let's change this to nav, and we're going to have two items in our nav. We're going to have Books and we're going to have Authors. Now let's also have those be anchor tags. Let's do this, let's make each of these a JSON object and we'll say Link is /Books, and Text in this case is Books. And then over here for Authors we'll do the same thing. Let's make sure we make the casing the same, there we go. Now, we've got from our nav, our nav is now an array, if we clean this up a little bit, there we go. So our nav, now has a Link and a Text for all of these things. If we come back over to our index.ejs, and now in our for loop, now we've got i is less than list, well we just made list nav, so we're going to change that to nav, li a, our href, is going to be that first item .Link, and this is going to be .Text. There, now what we're doing is we're passing our nav items, make sure we change this list to nav, and this list to nav, we're passing our nav items into our index.ejs from our app.js. And now we've created some navigation. Now if you've been following along, I should be able to right here, type gulp serve, and it's going to give us an error, because we have an issue. So let's pop over, and I can tell you exactly what that is. Right here we didn't close out our JSON object, boom, save that, let's run this again. Now this is one of those errors that you'll get from time to time. If you look, Expected indentation of 8 characters, basically when I hit Cmd+Shift+L it didn't like that, so we get this error, that error is because it likes to line things up properly, which is fine. Now that'll run. Okay, now, if I open up my browser and we refresh this page, localhost:3000, now look what we've got, we've got HOME, we've got BOOKS, and we've got AUTHORS. And if you look down at the bottom, localhost:3000/Books, localhost:3000/Authors, so we've got our navigation up and running, and now let's build out those routes so they take us somewhere.

Routing

So in order to build out our routes there's a couple of different ways we can do it. The way we've built out our routes so far is with this app.get/, and then we do our res.render down on line 13. And that's one way to do it, that's a way to just kind of build out all of your routes all in one place, but we also have the option to use something called a router. And so that's what we're going to do for this. So, we're going to create a new router, right here, we're going to go var bookRouter = express.Router. Now once we have that we can start building out the routes associated with our books routes. So if you remember, we're building out this route right here, so if I click on BOOKS I want to build out that route, so down at the bottom localhost:3000/Books. So, right here, let's do it right here on line 12, we're going to do bookRouter.route and we're going to build out route/Books. Now when we do it this way we can encapsulate all of the routes associated with /Books, all in this one route, so we can do .get, .post, etc., all down through there. Now for right now we're just going to do .get, and for the most part our website's only going to have gets associated with it. We might do a post when we're going to create users, but for right now we're just going to do the .get. Now for the rest of this it kind of works the same as our regular app.get, so we're going to do a function, and that function is going to take 2 parameters, the same 2 if you look right down here on line 17, app.get/ function req, res, it's the same thing. So we're going to do req and res. Now in this case let's just print out a message that says, yeah we got there. So let's do a res.render, let's not do a render, let's do a res.send Hello Books. Now we have a router, and that route is /Books, and we've got all this stuff working, but what we still need to do is we need to tell the app that we're going to use this router. Let's clean this up a just little bit. So we're going to an app.use, and we're going to say hey, for / we are going to use bookRouter, and that looks kind of silly, because we're already doing something for slash and since we've got /Books up above, so let's actually just do this, let's say hey, we're going to use, for /Books we're going to use the bookRouter, and now that I've put the /Books here, let's take the Books out right there. So now /Books/ is going to say Hello Books. If we put additional routes in here, I'll give you another one. Let's do /Books/single, because eventually we're going to, instead of just having a list of books, we're only going to have one, Hello Book, let's do Hello Single Book. Now I have two routes hosted by this router, I've got books/ and books/single, both being hosted in this one bookRouter. And then this app.use says, hey everything under /books. So if we save that, make sure we get our semicolons in there, let's pull this browser back up, now let's just make sure you have your server running. Now I've, using Gulp again, and we just did a gulp serve so since it restarted I know I'm good. So I can go to /Books, and see now we get Hello Books. And if go /Books/single, now I get Single Book. So we've got a route set up and that's awesome, we'll minimize that back down. But now I want to render something different than just have Books, so let's add in some rendering in this next clip.

Rendering

Now in order to get a view to render, first of all we've got to create our view. So let's do a New File in our views directory, and we're going to call it books.ejs. And it's essentially going to be the same as what index.ejs is. So let's copy that and we'll paste it in there. Now let's look at that, and then we'll start changing things. So, bookstudy.js, in our app on bookRouter/, now instead of res.send let's do a res.render, and we are going to render books. Now remember when I do a res.render and I just send it books, it's going to look app.set, we set our views directory to ./src/views, so I have a bookStudy.js there so it's going to pull books. All right, now if I save that, and we pull our browser back up, and we go to Books, ah, everything's broken, and it's broken because we're sending the nav in. If we look here, if we scroll down, remember I'm sending the title, and the nav, and all of that stuff in when I do res.render, and since we copied index over to books I got to copy all this stuff too. So let's copy that, all right, so our title's got to be books. We're not actually using that anymore, we just had that in there, but I'm going to keep it, and there's our nav. So let's save that, pull our browser back up, and refresh. There you go, now /Books looks like this. Now what we actually want to do is come up with some books, and we want to replace this list right here with some books. So let's do that. The first thing we're going to do is actually create some books. So, let's do right here, we're going to go var books = an array. Now in general we'll pull this stuff out of the database, but we're not talking about databases just yet, so we're going to hard code some books that we're going to send back over to our rending engine. So, what I'm going to do is I'm just going to copy and paste some stuff in here. And all this is going to be is a list of books. And so you can type in your own, you can do whatever you want, all we're going to use is title and author for right now, we're not even going to use genre yet. So title, author, it's just an array of JSON documents with those things in it, and I'm going to minimize that back up. Now when I do a res.render, I've got my nav right here, after my nav I'm going to send in books. Now I'm passing in an array that's nav and my books. Now if I come back over to books.ejs, let's scroll down and line 41, this is where we're doing our nav, see we're doing our for loop and spitting out all of our nav. If we copy this for loop, check this out, we're going to scroll down to where they start doing that list of items. And if I pull my browser back up, Repurpose Content to Reach a Wider Audience was that first line, so there it is right there, and the second one was 14 Useful Sites. So this div, this right here is what we want to do, so if I minimize all of these, or fold them all up, we're going to get rid of all of them but one, because we're going to loop over this. Okay, we're going to do this for loop again, now instead of nav.length we're going to do books.length, because we're sending in this array books. So for var i=0 i books.length i++, now inside that we are going to get rid of Repurpose Content to Reach a Wider Audience, we're going to get rid of that, percent equals, and we are going to say books sub i.title, and then down here books sub i.author.5%, there we go. And let's get rid of this 2 hours ago, and then Read More will actually be our link over to the full book. So we'll just do, we'll leave the Read More and our a href, let's clean that up right there, okay, our a href we're going to say is going to be equal to i, and we'll save that. Okay, now all we've done is we've created a loop, right here on line 102 where we're going to iterate over books, and then we're going to print out the title, the author, and then the link's going to be i. So if I pull the browser back up and I refresh Books, we get an awesome error, and what that means is we've got an unexpected token somewhere in our code. So let's pop back over there and we'll look at that. All right so the issue there is this simple one with EJS, look at 121, I typed an equal sign. When we're doing EJS, equals is going to print something out, no equals just executes it as code. So, here we're doing equals i because we want to print i out, so we got to take that equals out to make that work. If we flip back over, now I refresh, there we go. Notice I now have books. All right, so that's awesome for books, if you also look at the list, so 0, 1, and 2. Okay, so books is working. The next thing we want to do is implement this second piece. So let's go back over to our code. If we go back to app.js, now we've got this working, now we want to do this /single, and already there's a lot of code here in app.js, and that's not really the way we want things to work. So let's look at splitting this out into separate files so we can pull these routes out of our app.js and move that over somewhere else.

Separate Files

All right, so the way we're going to do that is we're come under src and we're going to create a new folder, and that folder's going to be routes, and this is where we're going to store all of our routes. Right now we only have book routes, but here eventually we'll have auth routes, and we might have author routes, and all of those different things. So let's right-click on routes and create a new file called books, let's do bookRoutes.js. All right, now what we want to do is we're going to do var express = require express, and we need to do that so that we can get access to our router. So we're going to do var router express.Router, now let's take everything we had over here in our app.js, so starting with var books all the way through here. Now our bookRouter, all of our bookRouter stuff we're just going to hit x and we're going to paste it into bookRoutes. Now here we called it bookRouter, so let's go back up and change that to bookRouter. Okay, so now I've got my list of books and my bookRouter.route, and that's it, I've pulled everything out and I've copied it over to a separate file, now I just need access to that. And so the way we do that, after we clean it up a little bit, the way we do that is by exporting it at the bottom. So we're just going to do a modules.export = bookRouter. All right, so all we've done is we've created our router, added everything to it, and then we export it. So over in our app.js we can say bookRouter = require ./src/routes/bookRoutes, and then down here app.use bookRouter Books, everything else just works. So let's save that, refresh this, oh, we've crashed, modules is not defined, okay. So come back over to our code, go to bookRoutes, because I said modules, it's not modules, it's module, and now it's blue so I know that I typed it right. We restarted, and there we go. So Books is working, separated out into its own separate file. And what we'll do as we do this is we'll create more routes files here in our routes directory and in app.js we'll just pull them all in right here. So as we do auth when we start doing users, we'll just do var authRouter = require and pull in our auth routes, and here app.use/auth, and that's kind of how that whole thing is going to work. All right, now that that's done let's going ahead and finish out our individual books and make that piece work.

Single Book Route

Okay, so back over on our bookRoutes.js, here about line 70 we've got this bookRouter.route/single, and obviously we're not going to be /single if we've set it up, let's pull this back up, if we set this up over, if I highlight over Read More, here we've got /4, /5, /3, so we want to be /books/3, /books/4, so what we're going to do is here in our bookRouter.route we are going to do :id. And what this is going to do is hand us whatever is beyond the slash when we're dealing with this route, and then the way we get a hold of that is down here inside our function, Express is going to attach whatever is behind that colon to our request object. So in this case I can just do req.params.id and that is exposed to me and that's going to give me whatever is beyond that :id. So if I do var id = req.params.id, now I can do a res.render, I can take this same render from up here and paste it in here, but instead of sending all of the books, I can just send the book that is books id. So I'm just going to send the one book associated with the ID that we're sending. Now I don't want to res.render books, I'm just going to do the one book. Now, I save that, now I have this new book that I have to render, so let's pop back over and set that up so that we can then display just this one book.

Rendering a Single Book

Now the way we're going to do this is by creating a new view. So we're going to create a New File called book, let's do bookView.ejs. And let's actually rename this books one, because now we've got multiple, let's call this one bookListView.ejs. Now we'll copy bookListView for right now, now notice we're doing a lot of copy and paste right now. And so here in just a little bit we'll start breaking this stuff up a little bit, so that we do partial so we're not doing all this copy and pasting. But for right now, it'll be okay, we're going to copy and paste bookListView and pop over to bookView, and we'll drop that in there. Now the only difference, if we scroll all the way up to the top, collapse the head, and the header, where we do this loop right here, books.length i++, we can actually get rid of that loop because we're no longer sending an array, we're just sending a single book, so let's delete that. And if we scroll down a little further now here we have books i 108, books i title, it's just going to be book.title, and then it's going to be book.author, and we'll get rid of the Read More, and then don't forget to close out this at the bottom. All right let's save that, pull our browser back up, now one thing we've got to fix is our link. So if we go to bookListView, actually there's two things we have to fix, if we go to bookListView and we scroll up to our link, a href = /books/ and the i. And then the other thing we have to fix is if we go back to our bookRoutes, render book and we want to render bookView. And then if we scroll up to our other route, just our /route, we're now rendering bookListView, we'll save that. All right now, refresh this page, and we added a semicolon to the end of our JSON objects, so back over, scroll down, right here, sometimes we're a little too semicolon happy, okay, now let's try it again, there we go, now it's working. Okay, so we're in /Books, if we hover over this one, or let's do this one, it's /books/1, if we click that now I just have that one book, and if I just change this to /4, there we go, I'm going to flip through several books. So now, ideally on this page right, we have more information and we might get there to where we'll have a description of the book and we'll have more information on this page that you wouldn't necessarily have on this main page. Okay, so now that that's there, there's one piece of copy and pasting I want to get rid of. This nav, we are doing this nav everywhere, and I like the idea of a dynamic navigation, and that's cool, but I don't like the idea of us having to copy and paste this nav and every time we change our navigation we're going to have to change it everywhere. So what I want to do is I want to create a variable called nav and I want to pass that into our router and let our router deal with that. So let's go figure out how to do that.

Router Functions

Now the way we're going to do that is, first of all let's copy this nav array, we're going to come back over to app.js and where we do our bookRouter right above that let's create a variable called nav. All right, now, what I want to do is I want to pass that in to my bookRouter. So actually we need this, hold on, we're going to cut that there and we're going to move it up above here. Now ideally we would pull this out of a database or some configuration somewhere, or something along those lines, but for right now we're going to hard code that. And then when I do my require routes bookRoutes, I'm just going to pass it in as a function. So now what we're going to do is we're going to change our bookRoutes, our require bookRoutes, into a function that's going to take nav as a variable. And you can imagine you can pass a lot of stuff in this way, you can pass database stuff in, or you can pass configuration files in, or whatever you want to do, but we're going to set this up so that works. So let's go back over to our bookRoutes and look at what we need to do to make this work. So if we collapse everything so we can see it all in one screen, close this, I've got express require express, that's going to stay the way it is, bookRouter = express.Router, that's going to stay the way it is too. But the last piece we're going to do is we're going to actually create a function right here, we're going to call it router, so var router = a function, and that function is going to take a parameter called nav. Now inside that function we're going to put all of that, minimize it back down again so you can see it all on one spot. Now I have this function called router that surrounds everything else, we'll clean that up. Now the last thing we want to do is actually return bookRouter out of our function. Now in our render, instead of rendering all of that we can now use this nav option that we have, this nav variable that's being passed in, and just use that, just like that. So now, all of my routes are going to use this nav variable that's being passed into this function and I don't have to change it every time I change something. Now the last thing we need to do is instead of module.exports bookRouter, I'm going to export this router function. So all I'm doing now is I'm exporting a function that will create a router, and then on the app.js side it's going to execute that function and pass in nav. So let's save this, let's make a change to our text here, we'll just drop the Ss, we'll save that, and when we pull this back up, if I refresh this page, now look, we're pulling our nav in from our app.js. So this is the way when you set up your routers you can pass things in and make those work a little bit dynamically based upon whatever configuration you have set up. All right, that's routing, we've got a couple of routes set up, we've got some dynamic navigation set up, we've got some req.params, some parameters that are being passed into this function so that we only pull a single book back, we're rending a couple different views, we've got a lot of web application stuff going on now, and things are trucking along. The thing that drives me crazy at this point in time is in bookRoutes we have this array of books, and I hate that. We're going to move everything over to a database in this next module.

Summary

So in this module we actually got down to the business of actually building out our web application. Up until now we've kind of been doing scaffolding and some other things, but now we're actually doing routes and we're delivering data back to the user. We started by building some routes for our application, we did our book routes, and a single book, and kind of set the stage for you to go and build your author routes. We're not going to do much with the authors in this course, but I would challenge you to go and build out an author routes, and see how that works. If you have any struggles with that, go down to the discussion board and post some code, and we'll talk through it. We did our book routes and we started talking about req.params and how we can pass parameters in the URL to help the application know where you want to go and what you want to do. And we also did multiple views, so we've got multiple views and we're rending different views based upon the route that you are going to. Now that's all cool, but let's now start making this thing data driven. We're going to hook up to a database and we're going to go. Now typically in a Node.js course you're going to see MongoDB, and so I'm intentionally going to do things a little bit differently here. We're going to do SQL Server, so we're going to hook up to a SQL server database, and then I'm going to do native Mongo, I'm not going to use Mongoose, I'm going to do native Mongo, and those are the two options we're going to do as we talk about databases.

Databases

Introduction

I'm Jonathan Mills, and in this module we're going to start talking about Databases and how to hook our web application up to a couple of different types of databases. Now we're building in our web application and we're working through, we've got some routes, we've got some data, but now we want to start pulling data out of a database to display that out to our website. Now, typically in a Node.js course you're not going to deal with SQL Server, a lot of times a lot of these course, and a lot of blogs, and a lot of tutorials, everything deals with MongoDB. And not everybody wants to use MongoDB so we're going to intentionally do something a little different. We're going to use SQL Server. So, if you have access to SQL Server and that's what you want to use for your back-end, we're going to show you how to do that. I'm going to use an Azure instance of SQL Server, but if you've got a local instance, or SQL Express, or something like that, this will all work just fine. We're also going to look at MongoDB. MongoDB seems to be the standard, it's what a lot of people use, we're going to use just the native MongoDB in this, there's a lot of courses out there on Mongoose if you want to use more of an ORM type environment, you can look at my RESTful APIs course or there's a Mongoose course out there, and there's other things. So I'm going to intentionally do things that aren't covered already in a lot of the other courses, or a lot of other tutorials out there. So, first we're going to start with SQL Server and get data out of an Azure SQL Server database.

MS Sql

Now typically when I'm going to start doing something different, or find a package that I'm looking for, I go out to npmjs.com. So let's go out here and let's look for mssql. This package, mssql right here, is a great package for dealing with SQL Server, it does a lot of the work for you, it can do a lot of different things. It has built-in JSON support, which is huge, so your results coming back from the database are already going to be JSON. It's got 20,000 downloads last month, so that's pretty decent and the latest release was just 3 week ago, so this is a well-maintained package that we're going to use. It also has good documentation, as you scroll down here everything that you want to do is extremely well documented. All right, so let's go over to our command line, kill Gulp, and we're going to do an npm install --save mssql. Now if we switch over to our package.json, you'll see it pops up right there, 2.3.1 is the version that we are using. All right, now in order to use this, let's pull back up that documentation, in order to use this we are going to have config, so we're going to pull in var sql = require mssql and do that, and then there's some configuration. Now I have set up a database out on Azure that I'm going to use, and I'm not necessarily going to deal with that piece of this because everybody's going to be different. If you have access to SQL Server, set it up wherever you have access, and then we'll work from there. If you don't have access to SQL Server, well, then we're probably better off on the MongoDB side. So I'll walk through the setup of MongoDB in the next couple of clips. So our configuration, user, password, our server, the database, and then if I'm on Azure encrypt: true, and then we'll work through that. So let's get that set up. So the first thing we're going to do is go over to app.js, scroll up to the top, and do var sql = require mssql. And then we're going to set up our config. Now here's what our config looks like, so for me, for my Azure instance this is what it looks like. Now this Azure instance will most likely not exist once this course goes live, so don't use that one, use your own, but user, password, your server, that's what it looks like. If you try and put the 14.3.3 on the end that's not going to work, just use it the way it is here and that'll be great. I've got a books database that's got a bunch of data in it. Now that that's open, or now that that config is there, we're going to open our database with a sql.connect, config, and a function with an error that we can log if that were to come up, so console.log. All right, now that I have an open connection I want to be able to use that everywhere else where I need to use it. So if I go over to my bookListView, not bookListView, bookRoutes, I'm going to minimize that. Now in my slash I want to be able to do a query right here in this function, and the way I'm going to do that is I'm going to create that SQL variable again. Now this may seem odd to you because app.js, I pull in mssql here, and then I open my connection, and then I don't do anything else with it in app.js, I don't pass it anywhere, I don't do anything like that. But over in my bookRoutes I'm just pulling SQL in again, require mssql. The way Node works is that the instance of mssql that it hands me right here is the same one that it handed to app.js, so that everything that happened to this mssql over in app.js is still valid over here on bookRoutes. So now, when I'm here I can just come down into my function and do a SQL query. And so the first thing we're going to want to do, in order to make this work, is inside my function we're going to set up a request, and then this will be very similar to what you would do with ADO or something like that, where you set up a request or adding a query, and then we're going to execute that query. So our query is going to be request.query, and we're just going to select * from books, because I have a table in my books database called books, and that's got a list of title and author ready to go. Now when that query comes back it's going to call a callback. And in typical Node.js style it's going to send an error or it's going to send a recordset. Now what's cool about this is that it's already in JSON, so the recordset that comes back is already JSON formatted. So if I just do a cl right here with the recordset, let's look at that and see how that worked out. So we'll start our server back up, gulp serve, and we'll run that. All right, so, why did I get a null right there? Well if we look back over when we opened it up, when we did our sql connect we just logged our error, we didn't check to see if there was an error, we just logged it, so that's why I get a null printed out because I don't have any errors. Now you might have gotten some errors with some indentations and things like that, clean those up and then that'll work, or just do an npm start if you want to avoid having to keep track of your errors and your JSHint stuff. Okay, now that that's running let's pull our browser up. There we go, if we go to Books, everything looks the same, but here this is what I get back from my database. I've got several books, there all a little different, I've got an ID, a title, and an author. Coming back from our mssql it already has everything JSON so there's nothing we have to do, there's no conversion or anything like that. I can actually just take this and drop it right into my render. So if I go back over to my bookRoutes, inside my request.query I'm going to do this, take my res.render and I'm going to drop it right there, and instead of books I'm going to do recordset. We'll save that, it already restarted, so let's refresh, there you go. This one is different, and so you know I'm pulling it from SQL Server. All right, now there's a couple of clean up things we've got to do in order to make this work. So if you come back over to our bookListView on our Read More, so line 113, we're doing the i so that iterator through the array, and that's not what we want to do anymore. Now we want to do books sub i.id, we'll refresh, yep, so know we're starting with 1 instead of with 0, so that's a good indicator of the fact that that's different. All right, so that's the first one, we've got bookRoutes pulling out of SQL Server, just like that it really is super simple on Node using this mssql package. Now let's do a query down here in our bookRouter for the :id.

Prepared Statements

Now for the ID the only big difference is we now have to pass in parameters to our query, and that's going to make things a little bit different. If we look back up here we can do select * from books and we could just add aware there and append things and that's bad, that's not what we want to do. We're going to do something a little bit different, and we're going to use a prepared statement. So, right here we're going to do var ps = sql.PreparedStatement, and a prepared statement is just a query with some parametrized options. And we're going to pass into this prepared statement our ID, and the way we do that we just do a ps.input, we're going to add a type to that of Int. Now that we have that we are going to execute our statement, and what we want to do is we want to do a select from books where we have an ID. So let's do a ps.prepare, a select * from books where id = @id, and we're going to add to that a function. And this function is what's going to get called when that prepared statement is set up, and we're going to add error just in case something goes wrong. Now inside this function we're just going to do a ps.execute, and we're just going to execute this prepared statement that we had up above and we're going to pass that in a JSON object. And our id is going to equal req.params.id, and that's going to call a function with a recordset. Now this is starting to get a little ugly, so let's fix this. When that recordset comes back now we want to take this res.render and put it inside this function, we'll clean it up just a little bit, there we go. Now, instead of books sub id, we're just going to pass back the recordset, now even though we have added the add id and we're only going to be pulling back one book, SQL doesn't know that, it's still going to pass us back an array so we're just going to return the first one. And now we'll clean up, make sure we get all our semicolons, and pretty everything up, all right. Now let's try this out, now if we try this out and we go to Books, we should get our list of books. Now if I click on this one, notice at the bottom it says books/2. When I click on that I just get the one book. So everything seems to be working. I did my select * from books, my book id, we added the add id, all of that seems to be pretty good. So, I've got my SQL Server up and running and that's all working. There's one thing that's kind of driving me a little crazy, which is this function is huge. There's a lot of stuff in here and we're doing a lot of stuff. So, let's talk about middleware for just a minute and how to interrupt some of these things to simplify some of these functions.

Middleware

Now with Express 4 we have the option to add something called middleware directly to the route using the .all function, because in this case every time I'm going to go to /:id, I'm going to be dealing with an individual book, that's just always going to happen, so instead of copying and pasting this select code for every individual route, the gets, the posts, the puts, the deletes, all of those, I can just do all of that right up here in all and add it back into the request. So, we start by doing all, and then we add a function. Now instead of doing just req and res we're also going to add next. And what next is going to do is let Express know to go ahead and run the next thing that's coming, so in this case we'll run all, and then we'll execute next, and do our .get. Now what I can do is I can take all of this code and move it up to all, so we pull the id out, we do our prepared statement, we do our select, but instead of our res.render we're going to do a req.book and add that book that we just pulled out of the database into our request, and then we're going to call next. Now down in our get we can send our res.render, but here in book we can just do req.book. Now the other thing that allows us to do is we can put all of our error handling up here in our .all function. So if for whatever reason we can't find our book, then we can send the 404 from right here, and the way we can do that is right here in our function we can do a check. If recordset.length = 0, we're going to do a res.status 404 with a send of Not Found. Now you could easily do a res.redirect right here to send it back to the whole list of books or whatever you wanted to do, and then otherwise we'll add it to the request and call next. So this way right here in our middleware if I'm doing a post, or a put, or a delete, or a get, whatever, I'm going to look for the ID and if I don't find the ID I'm going to send it a 404. If I do find the book, then I'm just going to move on to the next function, I'm going to call whatever's next. So let's save that and we'll try it out. So here I have my books/2, and that still works, if I change this to 24, now I'm going to get a 404, that not found error, sweet. So all of that seems to work and that's SQL Server, that's hooked up to SQL, we hooked it up to an Azure site, but, you can hook it up to whatever you want to, or whatever you have access to. The next thing I'm going to do is start talking about MongoDB. So, I'm going to save this here and I'll drop this code out to the course materials, and then we're going to redo all of this database stuff now with MongoDB.

MongoDB

All right, now I've reverted all of my code back to where it was at the beginning of this module. So I've just taken all the SQL Server stuff back out and we're back to just serving up everything out of this array of books like we had at the end of the last module. So, if you can revert back that's fine, if you can't don't worry, actually it'll save yourself some typing, we'll just change all the SQL stuff to MongoDB stuff now as we go through that. All right, so typically a lot of times when you're dealing with Node.js you'll be dealing with MongoDB as well. It's part of the MEAN stack, MongoDB, Express, Angular, and Node. And so Mongo seems to be something that a lot of people talk about when they're talking about Node.js, so what I'm going to do now is I'm going to walk you through hooking up our web application to MongoDB. And so the first thing we're going to do, is we're going to run out to MongoDB.org and we're going to download MongoDB. Now depending on whether you're on Windows, or Mac, or all these different options, it's going to look a little bit different. So just click this button, we'll go to downloads, we just want to download. We'll take the current release, I'm going to do the Mac OS, you can do Windows, Linux, whatever you want to do, just click Download and we'll get it going. Now as you're running through this installation a couple of things to remember. The first one is in order to run MongoDB you're going to run a command called mongod, and that's what's actually going to fire off the server. So go to wherever you installed MongoDB and just do a mongod and that's going to kick off your server. Mongo, the command mongo, is going to run our command line. And so at any given point when we're working with MongoDB on our application, the Mongo server has to be running, and that's MongoD, and then we're going to run everything from the command line. So, let's pull up a command line, and I'm just going to type mongod and I'm going to run that, and now I have, see right here on the bottom waiting for connections on port 27017, that means my MongoDB is up and running and it's ready to go. If you get an error right here, the most common error is that it needs a directory called c/data/db or /data/db, so if I go to /data/db that's where it's going to put, these are all of my MongoDB databases that I use for all the various projects and work that I do and all of those types of things. So, if it doesn't have this data/db directory, it's not going to work. So, if you type mongod and everything breaks, make sure you have a directory data/db. All right, so let's fire that back up, and I'm going to minimize that, and I'm just going to leave that running for the rest of everything that we do. Okay, now next, we'll take another command window and we're just going to type mongo, and see now I've connected, everything's working. To see what we've got going on I'm going to do show dbs, and these are all of the databases that I have. Now you don't have any databases right now, if you've just started you probably don't have any of those, and that's cool, don't worry about it, but we're going to come back to this here in just a little bit and we're going to get some stuff going. So, if you can do this, your Mongo's up and running, it's installed, your data/db directory's all set, so we're going to start working on getting our MongoDB hooked up into our web application.

Admin Routes

Now as of right now we have MongoD installed, and MongoD running, but we don't have a database, we don't have a collection, we have none of that stuff. And so what we're going to do is let's build something inside of our application that's going to take this array of books that we have, and I just manually typed a whole bunch of books, and you don't have to type the same ones I have, these are all old time books, all classics, you can go build an array with whatever kind of books you want, and then let's add this array into the database. So what we're going to do now is we're going to create a set of admin routes, we've got book routes here, we're going to create some admin routes and then we're going to use those admin routes to populate our MongoDB database. So in order to get some admin routes created we're going to right-click on our routes directory and we're going to create a new file called adminRoutes, and we're essentially going to do the same thing in adminRoutes that we did in bookRoutes. So we're going to start with these two lines of code, var express = require express and var adminRouter = express.Router, and then we're going to create some routes. Now in bookRouter, we, if I minimize this, we created a function and we passed the navigation in and we did all that kind of stuff, we're not going to need that for the adminRoutes, but I want to keep everything running similarly, so everything operates the same way so we have a cohesive structure to our application. So I'm going to do this same thing, this same line of code over in our adminRoutes. So even though right now we're not going to have a nav, we're still going to operate like we have our nav. So we're going to close that, and then our module.export is going to equal our router. The last line of code, when we execute our router, what we're going to want over on the other side in our app is our adminRouter so we're going to return our adminRouter. Now we're going to set up our route. Now the first thing we're going to do is do a route, so let's say we have adminRouter.route, now let's create a route that's called addBooks, and when I go to this route as an admin it's going to automatically insert into the database a set of books. So the route is addBooks, if I send a get request to addBooks, now we've got to write that function. So it's function, req and res, and then the actual function, and already it's yelling at me because I don't have my semicolon, so let's stay on top of that, all right. Now this is where we're going to put all of our MongoDB code to actually do all that work, and we're not quite ready for that yet, so let's put a placeholder, let's just do a res.send inserting books, and we'll save that. So now when I go to /addBooks I'm going to get a message in the browser that just says inserting books, and I'm done. Now we need to hook this up in our app.js, so if we come back over the app.js and we scroll down to where we pulled in our other route, so line 13, var bookRouter = require, I'm going to copy this line of code. And instead of bookRouter, we're going to adminRouter, and instead of bookRoutes we're going to do adminRoutes, and then down here where we do app.use/Books for our admin routes we're going to go to /Admin and we're going to use the adminRouter. So basically what we just did is anything that goes to /Admin is going to look in that adminRouter to see if it's got a route for that route. And right now we only have the one route, we just have addBooks. So let's save that and we'll try this out. So let's go back in here and lets do our gulp serve, all right, and we're ready to go. Now, this is your chance if you've typed anything wrong, if you're missing semicolons, or spaces, or any of that kind of stuff go ahead and clean that stuff up just so it doesn't hamper you moving forward, and then we're going to pull our browser up and we're going to go to 3000. Now we didn't add a link to this so we have to type it in, so let's go to /admin/addBooks, there you go, we get that message inserting books right there, so our routes all set up, it's ready to go. The next piece is, let's hook everything up to MongoDB so that we can insert books into our MongoDB database.

Adding Books

So the first piece in this is to get a npm package that we want to use to run MongoDB from our application. So let's go out to npmjs.org, and we're going to search for MongoDB. Now the MongoDB package right here you can see is pretty heavily used, 885,000 downloads last month. This is probably pretty solid, this is the one we're going to want to use. So this is what we're going to use to hook up our front-end web application to our MongoDB database. This has really good documentation around it, a lot of what we're going to talk about is right here in the documentation, so I'm going to cover some of it and get you started and then you can do a lot of the rest of it using the documentation. So to get going with this we're going stop our server, just Ctrl+C out of that, and do a npm install mongodb. Now this is going to install this npm package, and as that runs there's a couple of things that might go completely wrong here, so let's talk about those real quick. If you get errors here, especially if you're on a Mac the first thing I would look at is making sure your Xcode is updated to the latest version, so, if it's not, update Xcode and then start over again. Also see this node-gyp, if you get errors around that you want to do an npm install -g node-gyp, if you have problems with that you can run that. Try those two things, if you get any other issues post a comment down in the discussion and we'll see if we can't help you out. Once that's installed, then we should be good to go. Now I didn't put the --save on here, so let's run this again with --save, and you'll end up with it, if you go back to our package.json file, you'll see it right there, 2.0.46, that's the version that we are using. All right, now that that's there and we've got MongoDB running, we can start kicking some stuff off. Now unlike what we did in SQL where I just opened a connection over in app.js and then I just passed it kind of through, we're going to do things a little bit differently on the MongoDB side, just so you can see a couple of different ways to do things. So, here inside of our Router, when we get into our route, we're just going to open and close our connection, right here in our .get. We're just going to put all of our MongoDB code right here and just open and close it just so you can see how that works. All right, so up top we're going to need to pull in this package, so we're going to do var mongodb = require mongodb and we're pulling in the MongoClient piece of this. We'll pull in a couple other pieces later on so you can see why we're pulling only a piece, but for right now we're just pulling in MongoClient. Now, right here in our get we're going to open up our connection. So, we're going to do a, create a variable called url and it's mongodb localhost:27017 and we're going to do libraryApp, that's what we're going to call it, so localhost:27017/libraryApp, 27017 was the default standard MongoDB port that it uses by default, if you've changed that to something else that's cool, just change that right here too and we can get going. All right, now that you have that url set, let's do the rest. So we're going to connect to MongoDB using mongodb.connect, and we're going to connect to our url. And then once it's connected we're going to execute a function. Now this function in a standard Node, JavaScript way takes two parameters, the first one is the error and the second one is going to be our db. Now that I've connected to the database I have connection open, things are ready to go, we're going to use a collection. So the way MongoDB works, think of it kind of like SQL Server, and MongoDB people are going to be frustrated with me when I say this, but think of it like your database is your database, just like SQL Server is your database, your collection is kind of like your table. So, I have a collection of books kind of like I would have a table of books, and I've got a collection of authors like I would have a table of authors. They're different enough to where that's not really how it works, but it's close enough to help you wrap your head around that concept. So we're going to connect to a collection, so here I'm going to do var collection = db.collection and we are going to do books, we're going to create a books collection. Now unlike SQL Server, in MongoDB everything's driven through a collection, so you can't do one query to multiple collections at one time, there's no joining, there's no selecting across, so everything's got to be in one spot. So we're going to do everything right now in our books collection, and we are going to insert books, remember the whole point of this admin route is I'm going to drop some books into my database. So, we do everything through our collections, so collection.insert, and we're going to insertMany, and we're going to insert our books. Now we haven't created this yet, on this side anyway, it exists over on our bookRoutes and we'll come copy and paste it here in a second. And once that's inserted it's going to execute a callback. So there's our function, and you can probably guess what the parameters of the function are, the first one is going to be error and the second one is going to be the results. Now, what results for the insert? Well when we insert an array it's going to hand us back that same array, but now with all the MongoDB stuff associated with it. So it's going to have IDs and those types of things now in that array. So the results are actually fairly important to us and this point. Okay, so our function with our results, we're just going to do a res.send, there's no point in prettying up a page or anything for this, we're just going to do a res.send, and send the results. And then once that's done we're actually going to close our database connection, we'll do a db.close. Now it might sometimes be easy to accidentally do a db.close, this doesn't work because what's going to happen is it's going to call this insertMany and then immediately close the database because we're asynchronous. So, you'll get closed socket or something like that in your error, so if you're seeing something weird make sure that your db.close is up inside your callback. Now if we look down through our errors, books is not defined, this is why I like having this plugged in here, as well as over on our Gulp side because here, right now it just reminds me, oh yeah, that's not right. We can go ahead and clean up a couple of the rest of these real quick before we bring our books over. All right so books not defined, now let's pull our books in. So if you go back over to our bookRoutes this var books =, we'll copy that and move that over to admin and we'll just stick it right up here. Now all this is, --- and you can type whatever you want in here, pick your books so you can do Harry Potter books or whatever you want to do, just list out your books, title and author are really the only two pieces that we're using right now --- it's just a straight array, curly braces. All right, now, this should be it, if we save this, and clean it up, and rerun everything, which means start my database back up, everything should just work.

Testing Insert

Now one thing we want to look at real quick before we start our server though, is here I'm doing a res.send results, and then down below on line 74 I'm doing another res.send inserting books. So I really don't want to do that, we're going to rid of that one, so that way everything will work right. And now I'll run gulp serve to start everything back up again. Now we didn't create a link for this and we'll do that a little bit later, for right now we're just going to go to /admin/addBooks, and now we get results back. So, see we get a result there and then we get all of our titles back, notice they have an _id now. That's why we returned it back when we do, so that we get that list of IDs so now we can query based on ID, if we wanted to. In this case we're not doing anything with them, but in general that's a good idea. Now to make sure that it actually worked and it actually inserted, and we know it did because we got IDs back, but I'm going to show you how to do all of this in the command line. So if we pull another terminal window over here I can do mongo with libraryApp, this is what we called our MongoDB database when we opened it up. Now if I do a show collections, I now see I have a books collection, and I can do db.books.find and that's going to give me this list, so I have inserted those eight books into my MongoDB database using that insertMany, using this insertMany command, and then passing in an array of books. If I only wanted to insert one book, I would just do insert one and pass just the JSON object, but in this case we wanted to insert a bunch of them, so that's what we did. All right, now that we have books inserted into our MongoDB database, let's go over to our bookRoutes and implement then selectMany and selectOne in our bookRoutes.

Select Many

Okay, so we're going to run over to our bookRoutes, but before we do I'm going to snag these two lines of code right here, this url = and our mongodb.connect because we're going to use those same two lines of code over on the bookRoutes. Let's grab those and we'll pop over here. Now the first thing I'm going to do is I'm going to delete this array, this array of books that we have in here. And the reason I'm going to delete it, we're not going to use it anymore because I'm going to pull everything out of the database and I don't want to accidentally be pulling from my array and think that everything's working. So just get rid of it now so that we know if I've got books, it's working. All right, so now in our bookRouter/ inside our get this is where we want to pull back everything, just give me all of the books out of the MongoDB database. So we're going to paste those two lines back in, and we're going to close out our mongodb.connect. Now in here we're going to do our MongoClient, now we didn't pull any of that stuff in, let's pop back over to our adminRoutes, scroll up to the top, this mongodb require mongodb client, we'll pull that one over too. Clean this up a little bit, all right now I have my MongoDB. Okay, so mongodb.connect, mongodb url, inside here we're going to create our collection. So we're going to do var collection =, and we're going to pull our collection out of our MongoDB connection. So db., and we're going to do collection books. Now with that collection we're going to do our find, and so if you recall on our command line we did db.books.find and that gave us this list. So that same command line applies over on this side. So we're just going to do db.collection, which we've done already, we've just moved that to collection, so collection.find. Now, we pass a query in here and we don't have a query, we just want everything, but if I was going to do a query, and we're going to do one when we're looking for just one item, I would put my query in right here, but we're not going to do a query right now, I just want everything. And I want toArray, because I want an array of all of the stuff we're pulling out, and this is going to be a function. All right, now what this function is going to pass us back, per the normal JavaScript, error, and then it's going to give us our results. Now this results is just that list of books from our database, so if I pull this whole thing right here, I cut that, I paste it, and then I move that over, I should just be able to return those results. Now, really we check for errors and we make sure we didn't have any errors, and we checked the results to make sure the results are what we wanted, and all those types of things, but that's just a whole lot of boilerplate kind of code that I'm not going to walk you through, you guys can kind of play with that, but in this controlled environment, results is always going to be our books. So that's what we're going to do. We'll save that, I'm still using books down below. All right, we'll come back to that later, everything else I think is good. So we'll save all that, come back over here, and we restarted already, so let's go back to our books list, and there's our list of books, and everything just kind of worked out. Now you may not believe me, smoke and mirrors and all that, so here's what I'm going to do, let's do a db.books.remove, we'll just delete everything out of the database, that is obviously very dangerous, don't do this normally, but now if I hit refresh, I got nothing, no books. Now I'm going to go to admin/addBooks let's put some books back in there, come back, refresh my books page, and there's all my books back. Now you might have a different picture here, this came out of our template that we're using, it's just a random face and once it selects a face you're going to keep that face. What we're going to do here in just a little bit, we're going to pull book covers from a third party source. So let's just, don't worry about the face right now, we've just got our book list. Okay so now we've got a list of books, now let's go implement our select a single book.

Select One

All right, so here we are back over in our bookRoutes. Let's just take this whole thing, if I do most of that, because here we're passing in our books.id, so we're just going to get rid of everything, pass that all in. Okay, so here we are pulling in our :id and if you remember from before that is var id = req.params.id. All right, var url, mongodb, now instead of find we want to just do findOne. Find gives me a whole bunch, findOne is going to return just the first one that it finds. So findOne, and in findOne we are going to now have to use an object id because if you go back over, if you look at the command line, one other thing to notice when I'm doing a find, I can do a .pretty and it's going to give us a nice, better look on the command line, if you look at :id right here, ObjectId is what _id is. So, I can't just do, hey give me an ID, I actually have to create this ObjectId thing that MongoDB uses for the ID. And so that's another step that we have to take in order to just do the findOne by ID. So let's come up to the top and we're going to do var objectID = require mongodb.ObjectID. And that's going to let us deal with these ObjectID things that we have. All right, now let's scroll back down, so I have my ID, req.params.id, and really what I want is this to be an objectId, so instead of doing that right there I'm going to create a new objectId. And I don't remember what I called it, just objectId just like that, okay, req.params.id. Now I have an object called, that's an objectId of that id that we're using. All right, now mongodb.connect, we're going to our collection of books, we're going to do a findOne and we're going to pass in an JSON object that's going to let us pick just one thing. So in this case we're going to say I want my _id to equal that id. Now I'm not toArraying anymore so I'm just going to get rid of that, and I'm just going to pass the function as the second parameter to my findOne. Now the only other thing to revert this back to is I've got just book instead of books. All right, that is it, oh, and I've got to render just my bookView. All right, we're going to save that. We're starting to pile up some errors down here in the bottom, mostly trailing whitespaces, which I'm okay with for right now, we'll clean that up here in just a little bit. So, for example it doesn't like the fact that I have a trailing whitespace right there, so if I get rid of that. And just as we've copied and pasted stuff, we've built up some of those. So we'll clean those up, or you can go through and clean those up if you're ADD like that and that's fine, but for right now I'm just going to leave them because you don't have to watch me click through and fix them all. So, bookView, books, nav, results, all right let's save that. Now one last thing to change before we can test this. Over in our bookListView, right now if we scroll down to where we display all of these things, that's pretty far down, right here in our stories, if we, here we're doing books title, books author, and then we just right here do a present = i, that's just because we're looping through this array and we don't want to do that anymore, we actually want to have the id. All right, and so I want _id instead of that i. So we'll save everything, we've got our bookRoutes, we've done our findOne, we're passing in a query, we're doing all of that kind of stuff, let's save all this, and then see what we got. Come back to our command line, notice we've restarted it automatically, all right, so, let's look at Books, everything works. Now look down at the bottom, localhost:3000/books, and now I've got that big ID instead of 0, 1, 2, 3, 4, all that kind of stuff, so I'm going to click Read More, and I just got the one book. If I click back, scroll down, and then I'm going to click Read More on The Time Machine, it's a different ID now, click on that, I get The Time Machine by H.G. Wells. Okay, that's it, that's how MongoDB works if you're just doing native. I opened up a connection, I connect to a collection, and then I just do my findOnes, my finds, all of the same kind of command line stuff I've got, I'm doing here kind of the same way. We just pass JSON objects in. Now I have no control over what I get back, and MongoDB is kind of schema-less and that freaks people out sometimes and so there's another way to do this using Mongoose. Mongoose is kind of an ORM that will class up everything that you're doing, and you can set schemas and things like that. And if you want to do that, that's pretty well documented all over the place, and we've got a course out on Pluralsight by Mark Scott that's a dive into Mongoose, and I covered Mongoose in my last course, my RESTful APIs course. So if you're interested in using Mongoose you can check those out over there, otherwise I'm going to complete the rest of this course just using the MongoDB driver directly, just the raw MongoDB stuff. So that's MongoDB. What we're going to do now is we're going to add the concept of a user because we've added an admin task and we've done some other things, and so I'm going to create a new set of routes that are going to let me log in, and log out, and create a new user, and all those types of things. And we're going to tie everything we've learned up to now in order to make all that stuff work. And we're going to add in a couple of new things too, like we're going to do posts so that we can create a user and log in a user, and we're going to pull in Passport to do some things.

Summary

All right, we covered a lot of ground in this module as we worked through building out our web application. And now we are data driven, we've hooked it up to a database, or a couple of databases actually, and we're getting things going. We started by dealing with SQL Server and we hooked up to an Azure instance in this case, but you can hook it up to whatever instance you have available to you, and pull data out. We looked at how to select many, we did prepared statements, we did all that kind of stuff. We also started looking at MongoDB and we looked at using the MongoDB driver, just the core driver for MongoDB in our Node application. I showed you guys the command line, how to do some simple querying from the command line, and how to look at see what kind of data you've got in your database. We looked at inserting data into our database using the insertMany command line to get some data into our database. And we did find and findOne, so we found a bunch of data and then we just found one. We have made significant progress and we're almost done. We've got a couple modules left to get going here on building out our web app. We're going to do users and authorization next and building out a login form and all those types of things. So stick with it and we're almost there.

Authentication

Introduction

I'm Jonathan Mills, and in this module we're going to tackle Authentication. So we're working our way through building out a web application. We're building a library app, we're looking at books, and authors, and listing books, and all of that kind of stuff, and we've come quite a ways. We've got a page up, we've got all of our scaffolding up, we're pulling out of a database now, we looked at SQL Server, we looked at MongoDB, and now we're going to start creating users. So I'm going to create a user account and then allow myself to log in as that user over time. We're going to cover authentication, which means we're going to sign in, username, password, we're going to check the password, we're going to do all of that kind of stuff. We're also going to look a little bit at authorization, meaning as a logged in user I'm going to have access to somethings that non-logged in users won't have access to, and I'll show you how to work through all of that. And we're going to do all of this using Passport. And Passport is an authentication framework that's fairly standard in the Node/Express world, and this is what most people seem to be using when they're dealing with this type of thing. And Passport is going to do a lot of the heavy lifting for us as we work through this process.

Sign in Form

Now if you've been following along with us so far you should have a lot of stuff done. We've got our app.js that's pulling everything in and we're rendering some views. And we're going to start off, in this module, by creating a sign up form, so just a username, and a password, and you click Submit to create a new user. And we're going to do that in our views, so if you go into src, views, and you go into our index.ejs, this is a page we haven't done anything with yet. So, if we scroll all the way down, we've just kind of left it as our storystrap template, if you scroll all the way down to where we start doing rows, I'm going to get rid of everything, if we just minimize some of these rows here, I'm going to get rid of everything but the first row. And we're going to repurpose this first row to be our sign in. So I've got a div here that we're going to use, I'll delete everything inside that, and I've got another div there that we're going to repurpose. So I've got two divs and what we're going to do is we're going to create a Sign In form and a Sign Up form just like that, there we go. All right, we'll save that. Now creating a form is going to be pretty standard, we're not going to do too much fancy stuff with this one. We're just going to create a form and we're going to name this one our signUpForm, and we're going to give it an action, and this is just where that form is going to post to. And we're going to create a couple of new routes to handle all this and we're going to do an auth/signUp, go ahead and clean this, there we go, and after our action, our method's going to be post. Now so far we haven't created a post yet, we've only done gets, and so this will give us a chance to do a post verb just to kind of see what the difference is and how that works. We're going to create two inputs, we're going to create a couple of inputs. We're just going to do a username, a password, and Sign up, a button, and that's going to give us just a standard, simple little form, nothing fancy. All right so now, I should be able to open up my site and click HOME, and I've got my Sign Up form. I don't have the Sign In form, we haven't done that, but I've got my Sign Up form, and I should be able to type a name, and a password, and click Sign up. Now when I click Sign up, it's not going to do anything, Cannot POST to auth/signUp. So now let's go through the process of building out our entire infrastructure to support signing up a new user.

Creating the Auth Routes

So the first step of making all this stuff work is to create our auth routes. So we're going to have auth sign in, auth sign up, all of those, so let's right-click on our routes directory and create a New File called authRoutes. Now for the most part this is going to look very, very similar to adminRoutes. We're going to keep our Express, we're going to create a new router, and we're going to connect to MongoDB. So let's just copy these three things and drop them in here. Now, it's not the adminRouter over here, it's the authRouter. And the same way we've done everything before, we're going to create a function, and then we're going to export that function as our module.exports. Now inside this function, we're going to start creating our routes, so authRouter.route, and in this case we're going to do our sign up route, so we're creating a new user because that's for the form we've got. So signUp. Now we're going to have two potential routes here. The first route is going to be a .post, this is what our form is posting to in order to create that user. So our .post route is going to call a function, and it's going to take req and res, just like everything else, and we're going to go from there. Now in this case what we want to do is we want to pull the username and password out of the post body, so the body of the request, and we haven't hooked any of that stuff up yet. What we need to do first, before we can do anything of this, is we need to add into our app.js something called bodyParser. So if we go over to app.js, we scroll up to the top, we're actually going to pull in var bodyParser, and this is just a package that used to be bundled as part of Express and now it's separate, this is just something that's going to automatically parse the body of whatever is coming into our request and setting it up as a nice JSON object for us. Now the way that's going to work is it operates as middleware, and we've used a couple of pieces of middleware already, we just haven't really talked about what that means yet. But right here where we have app.use express.static public, that's a piece of middleware, so that's something that when a request comes in, this piece of middleware looks and sees if the request goes to something that's in the public directory and if it does it just sends it on. Well that's what bodyParser is going to do too, we're going to have an app.use bodyParser.json, and bodyParser.urlencoded. And what those two things do is it looks to see if there's a body that's coming in that's JSON and it's going to parse that out and it's going to create a req.body object for us to use. And then bodyParser.urlencoded is going to do the same thing, but for urlencoded bodies. So now, with those two pieces, I should be all set. One thing we have to do is install those. So you see when I saved it, it automatically restarted and it can't find bodyParser. So let's fix that, let's do an npm install --save body-parser, and if we look at our package.json file, we'll see it pop up 1.14.1. Now to check all this out, let's do this, let's do a console.log for a req.body, we'll save that, fix our semicolon problems, and start our server back up. Now if we come back here, and I sign up again, I still get my Cannot POST, and the reason why I'm getting that is because we haven't hooked it all up yet. So, let's do that real quick. So I've got my route, I've got my router, it's doing all that stuff it's supposed to do, I do a console.log for body, it's exporting to route, I need to hook it up. So let's go into app.js and actually pull that in. So we'll copy adminRouter and make that authRouter, adminRoutes will become authRoutes, and then down here we'll add in our authRoutes. So up here we're just creating a variable that contains that function that is the router, and then down here we're just going to use that router for /auth. So we'll save that. Now remember right here this authRouter is going to be used as middleware, it's going to load that router into the application, one thing we didn't do that we need to do, come back over here to authRoutes, we need to actually return this router from this function. So let's come down here and do return authRouter, save that, don't forget to add our forward slash right there. So it's auth/signUp, pull up our browser, go back. All right, jonathanfmills, and we'll click Sign up. Now it's going to hang, it's not going to do anything because remember we didn't do much with this, but if we come back over to our console, look, I've got userName jonathanfmills, password Pluralsight. So, I know that in this post, req.body is being populated in this cool little JSON document, and it's ready to go, and the part that is doing that is this bodyParser. So if we scroll back up, this bodyParser right here is what is doing all that work for us. All right, now that we've got the route, and we're ready to go, now let's start hooking up all of the pieces of Passport so that we can take that user, that we clicked Create User, and actually turn that into a user object that our application can use.

Passport Middleware

Now when we're using Passport for simple authentication there's a couple of pieces of middleware that we need to put in place so that Passport can do what it does. The first one is Passport.initialize, and this is what it uses just to set itself up and get everything going. And the next one is Passport.session, and this is what it uses to place the user object into the session, pull it out of the session, and manage all of that user stuff for us. Now Passport session sits on top of the Express session, and that's not installed for us yet, so we're going have to install the Express session, Passport session, and all of those pieces now so that we can get Passport to work. Now here in app.js there's three pieces that we need to pull in, in order to make this work. So we're just going to drop in here cookieParser, which is what Passport is going to use to parse the cookie for the session, passport, which is what we're going to need to do everything we're going to do with Passport, and session, which is the Express session that we're going to use, or that Passport's going to use to store our user information. So before we go too much further, now we are going to have to install these three items. So we're going to do an npm install --save, and we're going to do all three of these, so cookie-parser, passport, and express-session, let's actually do cookie-parser not coomie-parser, there we go, passport, and express-session. Now once those three are installed, if we pop back over to package.json, there they are, express-session, cookie-parser, and passport. Now that those are all there, back over to app.js, we need to start using those three things. So if we go down to where we stuck all of our middleware, and that's right here line 21 where we do an express.static and we're pulling in bodyParser, let's go ahead and pull in the pieces of Express that we need in order to make this work. And so the first one is we're going to do an app.use on that cookieParser. The second one we're going to use is our sessions, so we'll just do an app.use our session. Now session takes a secret, and that secret can be pretty much anything that we want it to be, and that's going to be specific to you. So we're going to do secret, and in this case we'll just use library as our secret. And now that we've got session in place we can start putting in the Passport pieces that we need. So let's do an app.use on those, now that gives us all of our Passport stuff, well our Passport middleware anyway, there's a couple more things we need for Passport in order to make it work. And what I don't want to do is start mudding up our app.js with all of our Passport-specific code, so we're going to pull all of this Passport stuff out, normally a lot of people would do is they'd just start doing all of their Passport stuff right here, and it doesn't really fit. Separation of concerns would say that app.js shouldn't have all of this Passport stuff in it. So what we're going to do is we're going to come over here on the right side and under our src directory we're going to create a new folder called config, and we're going to create a new file under config and we're going to called that passport.js. And this is where we're going to keep all of our Passport code, and then we'll just reference it over here just the same way we do up here for our routers. All right, so the way we do that is right here instead of these two app.uses, line 26 and 27, we're going to drop this line of code in, and what this line of code's going to do is it's going to pull config/passport in and execute whatever's there, and we're passing in app. And the reason we're passing in app is because I'm going to take these two app.use statements and I'm going move those over to our passport file, and now that I have this app in there I can do app.uses over there just as easily as I can here. So let's cut these two lines, and we're going to move over to passport.js and do all this work over here. All right, so what we're going to do is we're going to start by pulling in passport, so that's going to get us started, but now that's the only thing we need, everything else is getting passed into us, so we need to create our function. What we've done everywhere else is start typing right there, we're going to create a variable, we're going to do passportFunction = function, and then we'll do module exports later. You won't always see it done that way, sometimes you'll just see this, module.exports = function. I don't necessarily always like to do it this way because I don't find it to be as clean and as easy to read, but we're going to go with it just this time so that you can see a couple of different ways that you might run into people doing this. And so passport.js, our config file, is going to export this function that gets executed, and so at this point if I do those two commands, app.use passport.initialize and app.use passport.session, just like we had done over on the other side, that works. Now there's two more pieces that we need, a semicolon so JSHint stops yelling at us, and get rid of that space right there, and that space, okay. We need to start pulling in the other passport functions and all those things we have here. Now when Passport is dealing with users it uses a couple of functions to manage our user and our user session. So the first one is passport.serializeUser, and serializeUser is what it uses to bundle our user up into the session to store for later, and so this is the function we would use to do whatever we want to do to trim that down. The second function is deserializeUser, and that's what it's going to use to pull that user back out of the session. And so, sometimes in serializeUser we'd just store the ID instead of the whole user object depending on the size, then in deserializeUser we would go back to the database and pull the whole user out of the database. The last piece it needs is a strategy, so passport-local is what we're going to be using in this case. We're only going to do local authentication, meaning we're going to create a username and password, and then we're going to store that in the database, and we're going to check against that later. The other strategies that you might use are going to be Passport Google, or Passport Facebook, or Passport Twitter to do all of your OAuth against those third-party OAuth providers. And we're not going to delve into that in this course, there's other courses out there that are specific to Passport and OAuth, so when you get done with this you might flip over there and check those out. So here in our module.exports we're going to add those serialize and deserialize user functions. So the first one is going to be passport.serializeUser, and what this is going to take is a function and it's going to pass into this function the user object and a callback. So, this is where we're getting ready to package that user up into whatever we want to package it up into so that it can store it in the session. So, we call the callback with the same thing all callbacks in JavaScript, the standard way, error and the result. So we don't have any errors right now, because we're not really doing anything, and then we have user. Now in this case if we wanted to only do the user ID this is where we would go user.id, or some such thing. In our case it might be user.emailaddress or user.whatever the key is that we can pull out of the database. Now, the next one is passport.deserializeUser, and I'm just going to copy and paste because the only difference between these two functions is a de. Okay, so the same thing applies here, here it's going to pass whatever was stored in the session, and this is for us to pull it back out. So if up here we did a user.id, down here we would do userId. And this is just for us to name it, for us to keep track off, it's going to pass something in, it doesn't care what this parameter is called, this is just for us to understand. And then here's where we would add all of that code, so mongo.findbyID, or some such thing, and we'd go pull that out of the database and then pass that user object back in. For us, right now, we have a username and a password, and so it doesn't make a whole lot of sense to do more than just add the user to the session and be done. All right, so that's serializeUser and deserializeUser. The last piece of this is our strategy, and this is what Passport's going to use to build out all of the local authentication that needs to be done. So in this case we are going to use a strategy called passport-local. So what we're going to do is our npm install passport-local. Now if we come back to our package.json, and we refresh, there it is, passport-local version 1. Now back to our passport.js, let's clean this up, try and stay on top of that, there we go. Okay, this is where we would put now all of our passport.local stuff, and there's a couple of things that we need to do for that to make that work. But again, passport.js is all about setting up Passport, if we're going to offer multiple authentication methods, which usually an application will, they'll do Google, and Facebook, and Twitter, and local, and LinkedIn, and GitHub, and all of these other options, you've seen it, you've seen websites that allow you to sign in 100 different ways, we don't want all of that code sitting in this one file. So we're going to do the same thing we did over in app here in passport, we're going to require a config that's going to have all this passport.local stuff in it. And we're just going to say, from here we're going go to strategies/local.strategy, we'll make that a function, we'll execute it, and everything will get done. So, over to config we're going to create a new folder called strategies, and we're going to create a new file called local.strategy.

Local Strategy

Now when we pop over to this new file that we've created, local.strategy, we need to pull a couple of things in. We need to pull in Passport, but we also need to pull in that local strategy that we installed, back over to package.json, right here, this passport-local version 1 that we've got. And then using the same structure we used in the passport.js, let's just use module.exports equals a function, and in this case, the way we set up a strategy is Passport needs to use that strategy first for handling, in this case, local sign in. So we're going to do a passport.use a new LocalStrategy. Now this LocalStrategy takes a, to start with, takes a JSON object that identifies a couple of pieces of information, and the first one is usernameField and the passwordField, so that when over in our views, our index view, when we had this sign in box, we created our username and our password boxes and their named username and password, so what this is just telling our local strategy is that, hey our username field is just called userName, and our password field is just called password. In some cases our username might be email, or whatever other thing we might have there. So, back to our view, username and password is what we're doing, okay, so our userName field and our password. Then, it takes a function, and this function is what it uses to determine whether or not this is an appropriate sign in, because it doesn't know, it's going to rely on us on the local side to tell it whether or not this is correct. And so it's going to pass us three things, the username, the password, and then our done callback, so we're going to write some code to identify whether or not our username and our password are correct. And this is where, here in just a little bit when we're saving things to the database, this is where we would go to the database, pull the username, check the password, and do all that kind of stuff. We're not going to do that quite yet because we're not quite there, all we're going to do is we're going to create a user. And this user is going to have two parameters, its username and a password, we're shortcutting this a little bit and not doing all the database integration and everything yet, just because I want us to get to where we can see some stuff working before we build out all that other infrastructure. And then once I have that username created I'm going to call that done callback with no errors and the user, clean everything up, okay. So all we're doing in our local strategy for right now is when somebody posts and I try and authenticate to my local strategy, I'm just taking whatever they gave for the username, whatever they gave me for the password, I'm creating a user out of that, and I'm handing it back to them. We're not doing any real true authentication yet, that'll come later, right now we just want to get some stuff done. Now the last piece of this, before we can start testing things, is to go back to our authRoutes. Now right now when we go to our router we do a /signUp and we just log to the console what req.body is, and if you remember that was just the username and the password. Well now we're going to do a little bit more. We'll leave our console.log there, but we're going to do a req.login. When Passport does all its stuff, this passport.initialize, and passport.session, and these pieces of middleware that we've created, it will add things to the request for us to use, and one of those things is this login function. And what this login function does is it allows us to tell Passport, hey this guy's logged in, this guy's ready to go, and normally when we're just doing a sign in like a username and password type thing, we don't have to call this function because authenticate is going to deal with that for us, in this case when we create a new user, I don't want them then to have to go and log in again, I just want to log them in directly. So we're going to call this req.login with our user, or in this case we haven't created a user so let's just add req.body, and then our function, our callback. And our callback we're going to do a redirect to a new thing called profile, under auth. And all this means is what we're going to do is we're going to type in our login and password, I'm going to hit Submit, and then our req.login is going to take us over to auth/profile. But we don't have that yet, so let's add that. So we need to add another route called profile, and when we do a .get to our profile route we need our function with req and res, and all we're going to do here is we're just going to do a res.json and send our req.user. Okay, req.user is how Passport lets you know this guy signed in and here's his information. So, if I'm signed in properly and everything's right, Passport's going to append this user object to my request, and then I can use that to decide what I have access to, and what to show, and what not to show, and all those types of things. So let's clean everything up real quick. All right, now let's run this and see what all we've missed. So let's do our gulp serve, all right everything's running. So let's go to our localhost:3000. All right, we've got our template and we've got our Sign Up form here, so we're going to type our name, and a password, and we're going to click Sign up. Now when I click Sign up if everything's gone well we're going to go to our profile page, and if things haven't gone well we're going to blow up, there we go. So, when I click Sign up and I clicked that button, let's walk through the state of events that happened. I clicked Sign up, we did a .post to our sign up, this signUp logged everything to the console, and there's our log to the console, and then called req.login with our req.body, and when it called req.login it just added this particular user object to our session, and then Passport called our serializeUser, our deserializeUser, all of these pieces of information, and made that work. We haven't done anything with the local strategy yet, so that's why we haven't called anything passport.local yet, all this did was it signed me up. Now the next piece is let's create this user, actually save this user to the database so that we can then use our local, our passport-local strategy, to sign in to that user.

Saving the User

Okay, so back over here in our authRoutes, when I do a post and I have my req.body to save the user to the database, we're going to do our MongoDB and we're going to open up a connection to our MongoDB instances, our library app, mongodb.connect, our url, and then what we're going to do once we've connected. In this case the collection is going to be our users collection. Now we never created a users collection, right now all we have is our library, or our books collection, so the beauty of MongoDB and part of the way this works is I need a users collection, I'm just going to start using it, and it's going to create it automatically the first time I do an insert into that collection, which is kind of awesome. So, one of the reasons why I love working with MongoDB especially when I'm building out new things, is that there's not a lot of overhead. I can just add a new collection just write here in my code, and I'm done. Now we're going to create a user object, not a full blown object, but just a little user JSON object. And he's going to have a username, or she, and it's going to be req.body.userName, remember this is case sensitive, and then password, req.body.password. Now once that user is created we're going to do an insert, and we're going to insert that user. Now I'm just now creating this user collection so I know it's empty, so I'm just going to do a collection.insert user. What you would most likely do, is do a select first and see if you find that username, and if you do, you throw an error, but for right now we're just going to do our collection.insert with a function on what to do after our insert is done. Error and results, now we're kind of wrapping off the screen, so we'll clean that up. All right, now in this function after we've inserted the user we are going to call our req.login. So this moves up here. Now instead of adding req.body to our login, let's add results. Let's see what that looks like. So we'll save all that, I've got one little issue, we're missing a semicolon right there, trailing whitespace, and then we've got some indentation issues, all right. Now that that's all clean, we've restarted automatically, so let's go back to our browser. In this case, we'll come back here, we'll refresh, type in a user, actually let's do something nice. I'm going to click Sign up and it blew up, and it blew up because our database didn't open, and our database didn't open because I don't have the database running. So this is what's going to happen when that happens, so just going to type mongod, now I've got my database running. Ctrl+C, gulp serve again. All right, let's go back. Okay now, check that out, this is not what I wanted to come back. So this gave me my full results, and I did this so that you could just see what that that result looks like. Really what I want is ops sub 0, I want the first result, and the reason why I want that is I want this ID right here, that's what I'm looking for. All right, so what I really want, instead of results, is that. Now if I come back over here and I do mongo libraryApp, and I do show collections, now I do have this users collections. And at db.users.find, I've got a couple, and that's because I've been playing around, so let me remove that, now I've got nothing. So let's do this again, and let's see if this works. So we're going to come back, Sign up, there we go, now my user is just the username, the password, and our ID. So now that that's done, let's implement our sign in so I can type my username and my password and pull this same user back out of the database.

User Sign In

All right, now let's implement the sign in associated with this app. So, back here, we've got a Sign Up and this Sign In, so let's build this Sign In out. So let's got to our index, first of all let's clean this up just a little bit, we'll save that, there you go. That's just a little cleaner. Let's do the same thing over here on our Sign In form. So we're going to copy this form, now we're going to do a signInForm, and we're going to go to auth/signIn, same thing post Sign In. All right, now we've got a form, we'll save that, refresh so you can see it, there I go, now I've got this form over here. I want to be able to type that, click Sign In, and actually have it work. Right now I can't post because we haven't created that, but that's what we're about to create. So if we go back to our authRoutes, right now we've got our signUp route with our post, and our profile route with our get, we need to create our sign in route. So let's do our authRouter, we're going to create a route called signIn. I put a semicolon, take that semicolon back off because I'm going to chain a .post on here. All right, now when we post we're going to do a function, ah, we're not, when we're posting to a route where we want to use Passport, so here we're going to do our passport.local, we do things just a little bit differently, in this case here when our post, we're just going to call Passport. Now I don't have passport here so we need to pull that in. There we go, passport = require passport. Now here in my post I'm going to do passport.authenticate, and this is going to just hand everything over to Passport, and Passport's going to deal with whether or not this user is the right user or not. And I'm going to tell Passport, hey Passport, let's use our local strategy. If I was going to sign in with Google and I had /signin/Google, I'd use the Google strategy, or whatever. So this is where we just say hey, we're going to use the local strategy. And then we're going to give it an option, just one option in this case. I'm going to say hey, if it fails, we're going to go back to /, we're going to go home, otherwise if everything succeeds, we're going to run a function, req and res, same as always. And I'm going to do this same redirect, I'm going to do a res.redirect to the profile. So in this way if I sign in appropriately, I'm going to send everything over to the profile, if not I'm going to go back to slash. So we'll save that, clean everything up, all right. Let's try this out and see what happens. We're going to go back, we're going to type our name, click Sign In, look at that, it worked and I have a username and password called jon. So what that means is when I click Sign In, when I click Sign In this post handed that off to passport.authenticate, and this passport.authenticate local created a user object in my session, all in my request, that now my /profile has access to, but jon, jon was not the user I had created earlier, and the reason for that is when, in my local strategy look at all we're doing, remember we set this up a little bit ago, I'm creating a user out of the username and password and I'm saying yes, that's a good user, and that's all I'm doing. I'm not checking anything else at this point on this user. We'll do that here in just a second, but our local strategy is set up. This user is now logging in, not well, we're not doing anything in the database yet, but our user is logging in and we're getting our user attached to our request so that we can do some stuff with it. Now let's actually check the database and implement that piece of this.

Verifying the User in the Database

All right, now here in our LocalStrategy we're going to start adding in some MongoDB stuff. So the first thing we need to do is pull in MongoDB. So mongodb = require mongodb MongoClient, we've done this a couple of times so this should look all familiar to you. Now, down here we're going to do the same thing we've done before, so add our url, add our Mongo connect, our db.collection, it's going to be users, and then right here we're going to do our collection.find, but we are going to do our findOne because we only want one item back, and we're only expecting one item back, that's more important, but if there's more than one thing that defines, it's only going to return the first one. So we just know I'm going to get one thing out of the database here. And our query is going to be username. So if we look back here we have username, and there's our username, so that's what we're going to do. And we are passed the username in our function, up here on line 10 passed into our function is a username so we're just going to use that username. So the function that we're going to execute when that findOne comes back, it takes two parameters, error and results. Now the results in this case are going to be the full blown user object that we had. So in this case we want var user to equal results. That's assuming we get results back, and we checked for error. Now, if everything's good, we're just going to call done and be done with this. And in this case now my user is going to have that ID, so that's how we'll know it's good. So I'm going to save this. Now, connected to Mongo, users, we're going to do findOne on the username, and we're going to add our user is the results, so it comes back, and then we call done with that. So that should mean that now when I type jon here, and I click Sign In, I now am pulling, based upon the fact that I have that ID, I am now pulling that user back out of the database. Now my password's wrong, so let's fix that, notice over here in my authRoutes I say failureRedirect to /, if it works we're redirecting to auth/profile. So if we come back to my strategy, in my results, if my results.password = password, then we're going to use results for our user and we're going to call done user. Else we are going to call done with Bad password and null for my user, and null for my user. So we'll save that, come back over to my browser, so if I come back, I refresh this page, all right jon, and jon, I click Sign In, I get Bad password. If I do jon and Pluralsight, I click Sign In, I get my user. Now notice if I typed in a bad password I actually got an error message Bad password, and that's not what we wanted, what we wanted was to redirect, if we look back at our authRoutes what I wanted to do was to redirect to / on failure, and that's not what we did. So, let's fix that. Here, instead of Bad password null, this isn't the way that works, we don't just pass an error. If we have an error, a true error, we pass an error, in this case we're going to pass null for no errors, but instead of a user we're going to pass false because it's going to check to see if user is truthy and false is not truthy, so we're going to do that. And then we're going to pass a message and do it that way. So if we come back here, and we go back, now we redirect back around, but if I sign in properly, everything works.

Securing Routes

Now the last piece of this that we want to cover for Passport is actually authenticating against some routes, well authorizing some routes. So right now I can get to auth/profile no matter what, so if I restart my server, and notice I just type rs and that'll restart, auth/profile is now empty, but I can still get there. And what restarting our server did was it cleared out our session, so now I don't have a user in my session anymore. I can still get to auth/profile even though I don't have a user, and that's not really what we want, that behavior's not okay. If somebody tries to get to auth/profile, it should kick them out if they're not signed in. So let's try and do that. So if I come back to my authRoutes, auth/profile should have a little piece of middleware right here, so I'm going to .all because we might at some point allow posting to profile, we won't in this course, but you might in general, and we're going to do our function req, res, next. And here we're going to say if not req.user, if not req.user we're going to actually just kick you back out, and we're going to send you to /. So if you're not logged in, we're redirecting you back to /, otherwise go on about your business, do the next thing, and go. So the only way to execute this .get right here is if req.user exists, if req.user doesn't exist this all is going to catch that and kick us out to /. So let's come back here, let's try and go to auth/profile now, ah, and we get an error, so let's fix that. AuthRoutes 37, and I'm leaving this in here so that you can kind of see what we do when things break, so src/routes/authRoutes.js line 37, undefined is not a function, so let's look at that, req.redirect, ah, you can't redirect off the request, you have to redirect off the response. All right, so let's try this again. I'm going to go to /auth/profile, and it's taking me back to the /, so if I go /auth/profile and just hit Enter, it's going to redirect me back here, but if I type my name and actually sign in and click Sign In, now I can get to auth/profile. And all that is, is based upon whether or not I'm signed in.

Securing Multiple Routes

Now oftentimes that's enough, I just want to secure that one thing to our profile, so this .all, but sometimes it's not, sometimes I want to do more than that. So if we go to our bookRoutes, I don't want you doing anything with books at all, until you're signed in. I want to know that you're signed in before I get dealing with books at all. And so instead of doing a book.routes/.all and a book.routes/id.all, and having that in multiple places, right up here at the top I can just do a bookRouter.use and I can add that piece of middleware right here that covers the entire bookRouter, req, res, and next. And I can say here the same thing I said over in authRoutes, so if not req.user, we're going to redirect you back to login, otherwise go on about your business. So this, whether I'm going to / or a /id it doesn't matter, this is going to work for all of them. So if I open this back up, now I'm not signed in anymore because when I saved it would have automatically restarted, so if I go to Books, I'm redirecting back to my home page, but if I sign in, and I click Sign In, there I go to /auth/profile, but now I can get to my books, and I can get here, so let's copy this one just so you can see it all work, we'll restart, if I try to go back here again, I'm back to my localhost, or my home page.

Summary

All right so in this module we've done a lot. So we're building out our web application, we've got books, we've got our routes, and now we've got Passport working so that we can do users and authentication. So we created a new user, we saved it to the database, we authenticated, which means we now can sign in, we can do a username and password, and we checked that username and password against the database, and all of that stuff is done. We did authorization, so we secured some routes using Passport. So all of this was Passport, and this was just passport-local, so this was just us using a username and password local authentication using the passport-local strategy. Passport can do a lot more than this. Passport can do OAuth for all of your OAuth providers, Google, Facebook, Twitter, all of those, and if you want to implement those pieces, I've got another course out there called OAuth with Passport, that would be a great one to go watch if you want to add this on top of what we've got here. And we ended by securing some routes, we secured individual routes, so just our /auth/profile, and then we secured a whole bundle of routes. We secured all of our books routes by using just a general auth middleware. We are almost done, so stick with me, we'll get through this. The last piece we're going to do is we're going start doing a little bit of third-party API calls. We're going to add in some calls out to a website called Goodreads to pull in book information for that last summary book page, and then we're done. So stick with it, we're almost there.

Structure and 3rd Party APIs

Introduction

I'm Jonathan Mills, and in this module we're going to start talking about code structure, and also start to implement some third-party APIs so that we can pull data from someone else. Now we're almost done building out our web application. We've got everything put together, we've got a lot of different routes going, we've got data coming from a database, we're saving data from creating a user, and we have implemented Passport and authentication, and we've got all of the pieces of a website going, and now we're going to start cleaning it up a little bit. So we're going to talk a little bit about code structure and implement some controllers. And right now everything's in our router, so when I go to /book I've got all of my code that handles that get right there in one place. And we're going to pull that out a little bit into a separate file so that we can keep a separation of concerns and things will be a little cleaner. We're also going to implement services, so I'm going to show you how to implement a service that's going to deal with all of our third-party HTTP calls. And we're going to start calling a third-party API, in this case it's going to be an API called Goodreads, that we're going to use to pull book information out of so that we can show additional information on that single book page.

Controllers

So if we go into our bookRoutes for just a minute, and we look at the code that we've got in here, this is fairly complicated, maybe not complicated, but it's definitely a lot, and it's very difficult just to look at this really quick and say, hey what routes do we serve? I just want to know the routes that this router takes care of so that I can just look at it and then move on. And I can fold code, I could click those two, and I could click that, and say, look I've got a piece of middleware on line 8, I've got the route to slash, and I've got the route to :id. I've got those three routes, but then I have these functions here that, normally, I'm not going to fold code just to see. So one way that we can clean this up a little bit, we can separate out the routes that we serve and the actual functionality around those routes a little bit, is to use something called controllers. And so what we're going to do now is we're going to start building out some controllers for bookRoutes, so that you can see how we can separate these pieces out. And if you're going to unit test, unit testing the controllers actually becomes a lot easier as well. So we're going to right-click on src and we're going to create a New Folder called controllers. I'm going to right-click on controllers and create a New Folder called bookController.js, although I created a folder so that's not going to work, a New File called bookController.js. All right, now whenever we're using something like a controller or a service that we'll do here in just a little bit, the way we structure this matters a little bit. There's a lot of different ways you can do it and if you look out on some other sites you'll see a couple of different ways. I'm going to use the revealing module pattern, which basically means we're going to create a function, so bookController = a function, and I can pass something in here, like we've been passing nav around, we're going to pass a service in here in just a minute, and then I return this function, and that's what's going to come out of my service. Now I can return this function already executed, or I can just return the function and have the calling piece executed, and then we're going to pass something in, so we're going to pass in our bookService and we're going to pass in a nav. So we're not doing anything with the bookService yet, so I'm just using that as a placeholder for right now, but now what we can do is create some functions. So I can create getIndex as a function, and then the way I expose that function is by returning a set, a JSON object set of items. So in this case it would be return, and a JSON object with getIndex, and the function getIndex. This way I can create all of my methods up here and then down at the bottom I just have a little bundle of functions that I can easily look at and say okay, this controller has these methods on it, because I might have a whole bunch of other functions in here that I'm not returning, more of what in OO world would be like a private function. I don't what to expose those and I don't what to see them. So in this case, we're going to lay out our bookRoutes for the functions in this controller and then down at the bottom we can just look at this return and say, okay what routes am I serving? So right now we're doing getIndex and we're also going to do, if we look over at our bookController, or at our bookRoutes, we've got our index and we've got our :id. So the other one we'll do is getById. Now that function doesn't exist yet, so let's create that. Okay so now our controller serves two routes, getIndex and getById, there we go, lowercase getById, now it's blue, we know it works. Okay, now what these functions are is just the exactly the same function as what you would have over on your route, so I can actually take this .get function, right here with the req and the res, and everything inside it all the way to right there, I can just take out. And that function that I just copied is what goes right here, just like that. Now my getById has my function and all of that, and you can see when I copy that next one, let's take this getIndex function and cut that one out there, and we'll paste that in, now you can see why I like this revealing module pattern because I can look at this and say, well there's a lot of stuff here, but if I scroll down to the bottom, there you go, I'm returning two. And especially when I get four, five, or six more route functions in here, I just like having this convenient little place I can go look and see everything that's being exported. Okay, now, we need a couple of things in our bookController in order for this to work. So we're using MongoDB, if I clean this up first, make sure I get all of my stuff, okay, and then up here, we're going to need to import MongoDB, and then actually if we look over at bookRoutes, up here, the MongoClient and the ObjectID. Now we don't need the router, and Express, and all that stuff because we're just building out the functions that are going to be used by the router. We don't actually do anything with the router itself, so we don't need bookRouter, and Express, or any of those types of things over here. So if we clean up our semicolons, and our spacings, there we go. Now I've got controllers built, I don't have that working in my routes yet, so let's save this, all right now we're going to include our controller. Now when we're requiring a function, just like we did over in our app.js, we're going to do the full file path, well not the full file path, but the relative file path. So, we are right now, in our bookRoutes we're in our router directory so we need to go up a level into controllers to bookController, and we don't want it to be cbookController, we just want it to be bookController. Okay, now, I have this bookController, so right here in my route I can do bookController.getIndex, except that's not going to work because if you remember this getIndex was part of a return statement of a function, this function right here, it takes a bookService and nav. Now we're not using bookService yet, so I'm actually going to move this down inside, and we're going to pass into it null for our bookService and nav. Now I have that bookController, and now it's blue so you know I've got it. Okay, and then our id is going to be bookController.getById, staying on top of all of our issues. All right, we've done a lot, but nothing that we'll see, but we're going to go ahead and run this and try it out. So if we pull up our browser, we've got to log in again, lowercase, click Sign In, there's that, and we're going to go to Books, and there we are, individual book, there it is. So, nothing to see really, it's working the same way it always has, but now our controller works. The one last piece of our controller that we're going to pull over is our middleware, because right now in our bookRoute we're using a piece of middleware here to make sure that we are logged in. So I'm going to cut this out, and I'm just going to say bookController.middleware, and we'll save that, and we'll come over to our bookController and we're going to create a new function that does this. Now, I'm actually going to comment that out because as we're working through the rest of this we're going to restart a lot of times and I don't want to have to log in ever time that our server restarts. So, we're going to comment that out and that's a way you can see that things have worked. I'm going to save this, it says empty block, so it's going to complain, hey this if statement doesn't do anything, that's useful. All right, now in order to make this middleware work down here in our return statement we need to add that. All right, now if we've done everything properly and I go back to my browser, and I click Home, I'm not signed in, I should be able to go to Books, and I get to Books now. And just in case you don't believe me, we'll restart our server, there you go, go to Books and everything works. Okay, so our middleware has been commented out and we commented that out in the controller, so everything's working.

Goodreads API

Now we're going to implement a service using the Goodreads API, and so what that means is that I want to go out and look up War and Peace, so one of the book in our list is War and Peace, and I want to pull back this image, this title image, and the name, and this information here, so that I can display that on my site and then maybe link back over to Goodreads as needed. So the way we do that is we start out by going to the goodreads.com/api, and right here there is a register for a developer key link, and so if you click that you've got to come in here and you put your login in, and fill it out, and you'll get an API key. Once you have that API key, you can start doing these API calls. And the call we're going to use for ours is show. And so we're going to do book.show, which essentially is this link right here, goodreads.com/books/show and then just the ID, but in order to get this in a format we want, this is what we actually end up doing, ?format=xml and then our key. If you click on this sample url right here, that's what it'll give you, it'll actually give you this. So this is what we want to implement. For every one of our books, we want to have a Goodreads ID so we can go out and link this. So what we're going to do next is we're going to implement this API call so that when I click on War and Peace it's going to display what we have on War and Peace, but then come out to Goodreads and display all the rest of that information.

Services

We can put all of that code in here in our getIndex if we wanted to, but we're already doing quite a bit actually, we've got our MongoDB stuff going on, which we'd probably pull out to a separate service or a DAL layer, if we were doing this for production, but we're going to pull everything out into a service. So right here when we created our controller we created it to accept a bookService, and what this service is going to do is handle all those API calls out to Goodreads. So the first thing we're going to do is create a new folder under src called services, and then under that services folder we're going to create a new file called our goodreadsService. And this is going to operate the same way that the controllers work, and first of all, the first thing I'm going to do is I'm going to rename this to .js instead of ,js, that's awesome. Okay, now this is going to work the same way that a controller works, so we're going to create a function called bookService, or actually we're going to call it goodreadsService because this is going to have the nuts and bolts of all that Goodreads stuff in it, and that's going to be a function, and then we're going to do our module.exports. Now for this course we're only going to do one function, we are going to create a function that's going to get book by ID, so var getBookById = a function that's going to take an id, and then it's going to handle all of the Goodreads stuff necessary to go get that. So for right now, let's just dummy this up a little bit so we can plug everything together and make sure it works, and then we'll come back in and fill all the rest of it after we're done. Now one thing we left off here, when we're doing a service we're going to go off and make HTTP calls and do all this asynchronous kind of stuff, so let's pull in a callback as well, and then when our service is done what we're going to do is we're going to call the callback with no error, and ideally a JSON document that's going to have some information, so let's just say description, it's going to have a description of the book that says Our Description. Now let's implement this over on our controller. So we're going to get a bookService and that bookService when we do our getById, we're going to go out to Mongo, we'll call our findOne, when our findOne comes back we're calling this render right here. But now what we're going to do instead, is we are going to call our bookService, and in our bookService we'll do bookService.getBookById, we're going to pass in our results.bookId, which we don't have yet so that's going to be something new because the _id is the MongoDB ID, and we don't want that, we want our Goodreads ID, so we'll have to add that to our database here in a second, and then our callback and, our callback was going to have, if we look back at our service, it's going to pass error and a description, so error and then the book results, so let's call it something different then results, we'll call it book. So inside this function we'll move our res.render to inside that, and our book is going to now be, include our book, so we'll say results, we'll just append on another book, which is our bookService book description. So right now every time we call /:id we're going to have an additional thing called book, and that additional thing called book is going to have a JSON object with a description and just Our Description on it. So let's hook that up to our view and then try it out. So in our bookView, if we scroll down to where we are doing our view, right here, here's my image, here's my title, here's my author, at the end of this, inside this div right here, inside this br let's add our description. So instead of book.author it's book.book. Okay, fix that book, b-o-o-k, the description, we'll try this out and see if this all worked. Save everything, let's open our browser back up, if I click Read More here, we are getting an error in bookController, line 54, so let's go look at that real quick. This is what I get for letting these errors pile up, this is why we have these errors down here to pay attention to them. All right, so, when we move stuff around our bookService needs to be closed, and we need a semicolon and everything. All right, now we restarted so let's refresh this page, there's one thing, there we go, here we go, cannot read getBookById, we didn't do something, and so if everything worked for you, you skipped ahead because we didn't do one thing that's super important. Let's look back at our error, Cannot read property getBookById of null on bookController.js line 43, so let's go to bookController.js line 43 bookService.getBookById, and up here we have bookService, but in our controller, in our route, we're still passing null, we haven't passed in our bookService yet, so let's do that. And I'm calling it bookService instead of goodreadsService for a reason, so because I don't necessarily want to tie all of my code to Goodreads, if at some point we decide we're going to use a different book service, I don't want to have to rename everything. So bookService right now is going to equal our goodreadsService.js, but later it might equal something else. So bookService = require, we'll create a little space, and it's going to be ../services/goodreadsService, and we're going to execute that. When we created our goodreadsService we're not taking any parameters right now, so we should be okay, and then we're going to pass bookService in when we create our controller, right there. All right, we'll restart, and now we've got some issues. Okay so goodreadsService, let's clean this one up, we've got all kinds of problems with this one, forgot the parenthesis, missing a semicolon, missing another semicolon, last thing we need to do in here is also return everything, we're not doing that. So down here we've got to return in our revealing module pattern, getBookId, all right, there we go, and down here we see Our Description. So our service is working, it's returning a JSON object with Our Description in it, everything's working just the way it should be. So let's implement now that HTTP request out to our goodreadsService.

HTTP

Now in order to make our function call to our goodreadsService we're going to need to use the HTTP package, so let's do a var http = require http. Now the goodreadsService is going to come back with XML, it's going to send us an XML file and this is what it's going to look like, so we don't want to deal with XML, we want to deal with JSON, so the other thing we're going need to use is a package called xlm2js. And the way xml2js works, and we're not going to delve to deeply into it, just take my word for it, is it's going to create a parser, so the last part is we have var parser = xml2js.Parser, and this is going to take a set of options, and we're going to say explicitArray = false. All right we're going to save that. Now to implement our HTTP, all we really want to do is implement an HTTP get request. And we're going to get a request out to our goodreadsService, so HTTP takes some options, actually the call looks something like this, http.request options and callback, and then we call .end. Now we need to create what these options are and what this callback is that gets called when this HTTP request is made. So the first one is going to be options, and this is just the JSON object that has a couple of parameters in it, the first one is the host, what are we making this call to? And in this case we're just calling goodreads.com. And then the second parameter is the path, what's the path that we are look at for this? And in this case our path is going to look something like this, let's clean this up, book/show, and then the book ID. So if we look back at our documentation, it's book/show, the book ID, the format, and the key. And in our documentation here for book.show, we send the format XML or JSON, and right now JSON's not working, and I want to show you that xml2js conversion. So we're going to leave it as XML, our developer key that's required, so you'll have to, if you haven't gotten that already get that, and then the ID. Now if you search Goodreads for War and Peace, which I've done, and you click on War and Peace, notice it's the same thing, I can actually get rid of everything after the 656, which is the book ID, and it's going to give me everything that that is. The only difference is we're going to have a format equals XML on the back. So War and Peace is 656 and we're going to hard code that for right now, in the next clip we'll fix that, but for right now we're just going to hard code 656 so this is what we get back. So we'll minimize that back, so book/show/656, our format, and our key, and then the next thing we need to is the callback, and this is going to take a response. Now the way an HTTP request works, there's pieces that are involved, and we have to actually package together all the different chunks of data that come back. And so the way we're going to do that is create a string and make it empty. And then response., when data comes back, so on data we're going to execute a function that's going to send us a chunk of that data, and when that chunk comes back we're just going to add that to the string. Now when it ends, response.on end, so when it ends, when it's all done we're going to execute a function, we left a parenthesis off of there, okay. In this case, now I have an XML document and actually if we cl that, str is going to be a big long XML document, it's going to look exactly like this right here, if we go back to this, it's going to look exactly like this. And so now that we have all that back we're going to parse that out. So now we use that parser that we created up here, this xml2js.Parser, to parse that out. So we're going to do parser.parseString, we're going to pass that string in and then we're going to pass in a callback. And that's actually going to hand us in typical callback fashion, an error and a result. So once we get that result back now we have that JSON document, now we have everything we need. So now we can call the callback from before, this callback coming into our service, where before we were just appending description here, well now, we're going to append result. So what we do as data comes back from our HTTP request we append it to a string, then when it's done we send that string to our XML parser, and then we just call the callback that bookController sent in with the result. Now, result isn't quite what we need, now if we look at this XML document there's a GoodreadsResponse and then there's a book, and so we want .GoodreadsResponse.book is really what we want. So let's save that, fix all of our typos, and all of our missing semicolons, add tick marks around our end, clean up our spaces. (Working) All right, now that that's all done, notice it's already restarted and it's already crashed because we don't have this xml2js. So let's Ctrl+C a couple of times and do our npm install --save xml2js and http, and when those are done we'll go to package.json and you'll see them pop in, there's http and xml2js. So we'll restart our server, and refresh this, and now we have our description. Now it's not enough to just have the description, I want this picture here too. So if we look at our XML document, and if we scroll down there's this image_url right here, so I'm going to do .image_url for our picture. So let's go to our view, our bookView, scroll up to this .jpg right here, we'll get rid of that, and we're going to do, instead of description book.book.image_url, and we refresh this page, and now we're getting our image back from Goodreads. Okay, so that's a service. One last thing actually before we go, notice these two brs right here. So, Goodreads is sending us back HTML, which is painful, we don't want to display that HTML, we actually want to format that HTML appropriately, and the reason why those brs are showing is because this percent equals actually is escaping all of the HTML, if we don't want it to escape the HTML we're going to use a dash, just like that, we'll save that, and now when we refresh it's not going to not escape that HTML, and actually do the two brs. Okay, so that's that. Let's now pass in that ID and then we're done.

Adding the Id

So if we come over to our adminRoutes, right here is where we populated the database with all of our books. Let's add to War and Peace here bookId, and that was 656, and then let's do Les Mis as well, and then we'll leave the rest, and that way we'll have to check and see if that worked. So if I do a search for Les Mis, that book is going to be 24280, so let's copy that one as well, and say Les Mis's bookId is 24280. Okay we'll save that, now let's do, on the command line let's do a db.books.remove, which can be pretty scary, remove needs a query, which makes it kind of safer until I do that and then it removes everything. All right so now there's no books in our database, and if I go back to our list, and I refresh, I now get nothing, but if I go to admin/addBooks, there we go, we just added books back in, and if I come back to Books and I refresh, now I've got my books back. All right, so let's try this out, let's go to bookController and say hey, if results.bookId, then we'll call our bookService, otherwise, there you go, otherwise, we're just going to call the callback, and we'll just call our res.render. And of course we just copied that, so we'll delete that, clean everything up a little bit, things have gotten a little crazy here. And in practice we would clean this up a lot more, but right now we just want to make sure that everything is right so that we can go. All right, now once again, if we have a bookId we're going to call bookService, otherwise we're going to render. Now in our bookService, our goodreadsService, we're just going to use our id here, so we'll save that, make sure we're running, and we are, so let's refresh this page, click on War and Peace, there's our War and Peace with our description. Click on Les Mis, there's our Les Mis description and there's our image. There we go. So we've got services making HTTP calls, and we've got controllers, and views, and all of these pieces built up, that's really all there is to it. There's do the same thing a lot of times to make a full blown app, but those are the vast majority of the pieces necessary to make an application work.

Summary

All right, now we have built out a web application using Node.js, Express, Passport, and many other pieces, MongoDB, SQL Server, all of that, but we've built out a full blown web application using those technologies. This last module we talked about structure and I showed you how to have controllers, and services, and views, and everything broken out into separate pieces to keep it a little more easy to follow. Our controllers dealt with all of the work associated with a route. The routers just held the routes and then passed everything else off to a controller, and the services did all the work of getting data that the controllers were going to use. We even talked about calling third-party APIs and we called the Goodreads API using the HTTP package and then converted the XML we got back from xml2js. So that's it, that's the whole thing. If you stuck with me this whole time then congratulations, that's quite a hefty course, so good job. If you have any more information that you need around this topic, feel free to dig into either my Passport course, which is going to go more into OAuth, or my RESTful APIs, which goes more into the different verbs you can have around your routes.